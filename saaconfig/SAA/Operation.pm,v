head	1.17;
access;
symbols;
locks; strict;
comment	@# @;


1.17
date	2003.08.31.22.19.34;	author jmarcus;	state Exp;
branches;
next	1.16;

1.16
date	2001.12.03.06.25.01;	author jmarcus;	state Exp;
branches;
next	1.15;

1.15
date	2001.10.04.20.21.46;	author jmarcus;	state Exp;
branches;
next	1.14;

1.14
date	2001.10.04.05.42.14;	author jmarcus;	state Exp;
branches;
next	1.13;

1.13
date	2001.09.26.16.57.41;	author jmarcus;	state Exp;
branches;
next	1.12;

1.12
date	2001.09.26.06.23.19;	author jmarcus;	state Exp;
branches;
next	1.11;

1.11
date	2001.09.25.22.47.35;	author jmarcus;	state Exp;
branches;
next	1.10;

1.10
date	2001.09.25.21.29.49;	author jmarcus;	state Exp;
branches;
next	1.9;

1.9
date	2001.09.19.05.26.32;	author jmarcus;	state Exp;
branches;
next	1.8;

1.8
date	2001.09.18.08.02.04;	author jmarcus;	state Exp;
branches;
next	1.7;

1.7
date	2001.09.17.05.48.23;	author jmarcus;	state Exp;
branches;
next	1.6;

1.6
date	2001.09.09.21.36.05;	author jmarcus;	state Exp;
branches;
next	1.5;

1.5
date	2001.09.09.20.38.42;	author jmarcus;	state Exp;
branches;
next	1.4;

1.4
date	2001.09.09.06.22.43;	author jmarcus;	state Exp;
branches;
next	1.3;

1.3
date	2001.09.09.06.20.45;	author jmarcus;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.09.03.25.30;	author nick07;	state Exp;
branches;
next	1.1;

1.1
date	2001.08.28.05.24.48;	author jmarcus;	state Exp;
branches;
next	;


desc
@@


1.17
log
@Clean up all the source with a nice call to:

perltidy -i=8 -t -pt=2 -bt=2 -sbt=2 -ci=4 -noll -sfs -nasc -ce
@
text
@#
# $Id: Operation.pm,v 1.16 2001/12/03 06:25:01 jmarcus Exp $
#
package SAA::Operation;

use strict;
require 5.002;
use lib qw(..);    # XXX This is for testing only.
use SNMP;
use SAA::SAA_MIB;
use Carp;

sub new {

        # ARG 1: String name
        # ARG 2: int type
        # ARG 3: int proto

        # This constructor creates new SAA operations.  It accepts three mandatory
        # arguments, the operation name, the operation protocol, the
        # operation type.  Once the class is instantiated, use the accessor methods
        # to configure the class properties.
        my ($that, @@args) = @@_;
        my $class = ref($that) || $that;

        if (scalar(@@args) != 3) {
                croak
                    "SAA::Operation: Insufficient arguments passed to constructor";
        }

        my $self = {
                name             => $args[0],
                type             => $operationTypeEnum->{na},
                protocol         => $operationProtocolEnum->{na},
                threshold        => DEFAULT_THRESHOLD,
                frequency        => DEFAULT_FREQUENCY,
                timeout          => DEFAULT_TIMEOUT,
                verify           => DEFAULT_VERIFY,
                tos              => DEFAULT_TOS,
                targetPort       => DEFAULT_TPORT,
                sourcePort       => DEFAULT_SPORT,
                controlEnable    => DEFAULT_CONTROL_ENABLE,
                dnsTargetAddress => undef,
                adminOperation   => undef,
                adminStrings     => undef,
                adminURL         => undef,
                adminCache       => DEFAULT_ADMIN_CACHE,
                error            => undef,
        };

        my $rc = _validateTypeProto($args[1], $args[2]);
        return unless $rc;
        $self->{type}     = $args[1];
        $self->{protocol} = $args[2];
        bless($self, $class);
        $self;
}

sub _validateTypeProto {
        my ($type, $proto) = @@_;

        if (scalar(@@_) != 2) {
                croak
                    "SAA::Operation::_validateTypeProtocol: method requires two arguments";
        }

        # This is a private static method for testing whether or not the type and
        # protocol are compatible.  It returns 1 if they are, undef otherwise.

        if ($type == $operationTypeEnum->{echo}) {
                return
                    unless ($proto == $operationProtocolEnum->{icmpEcho}
                        || $proto == $operationProtocolEnum->{snaRUEcho}
                        || $proto == $operationProtocolEnum->{snaLU0EchoAppl}
                        || $proto == $operationProtocolEnum->{snaLU2EchoAppl}
                        || $proto == $operationProtocolEnum->{snaLU62Echo}
                        || $proto == $operationProtocolEnum->{snaLU62EchoAppl});
        } elsif ($type == $operationTypeEnum->{pathEcho}) {
                return
                    unless ($proto == $operationProtocolEnum->{icmpEcho});
        } elsif ($type == $operationTypeEnum->{tcpConnect}) {
                return unless ($proto == $operationProtocolEnum->{ipTcpConn});
        } elsif ($type == $operationTypeEnum->{http}) {
                return
                    unless ($proto == $operationProtocolEnum->{httpAppl});
        } elsif ($type == $operationTypeEnum->{dns}) {
                return
                    unless ($proto == $operationProtocolEnum->{dnsAppl});
        } elsif ($type == $operationTypeEnum->{dhcp}) {
                return
                    unless ($proto == $operationProtocolEnum->{dhcpAppl});
        } else {
                return;
        }

        1;
}

sub name {
        my $self = shift;

        # Name is static once the class has been instantiated.
        return $self->{name};
}

sub type {
        my $self = shift;

        # Type is static once the class has been instantiated.
        return $self->{type};
}

sub protocol {
        my $self = shift;

        # Protocol is static once the class has been instantiated.
        return $self->{protocol};
}

sub threshold {
        my $self = shift;

        # Threshold is valid for all SAA operations.
        if (@@_) {
                my $th = shift;
                if (       $th < MIN_THRESHOLD
                        || $th > $self->timeout()
                        || $th > MAX_THRESHOLD)
                {
                        return $self->{threshold};
                }
                $self->{threshold} = $th;
        }
        return $self->{threshold};
}

sub timeout {
        my $self = shift;

        # Timeout is valid for all SAA operations.
        if (@@_) {
                my $timeout = shift;
                if (       $timeout < MIN_TIMEOUT
                        || $timeout < $self->threshold()
                        || $timeout > MAX_TIMEOUT)
                {
                        return $self->{timeout};
                }
                $self->{timeout} = $timeout;
        }
        return $self->{timeout};
}

sub frequency {
        my $self = shift;

        # Frequency is valid for all SAA operations.
        if (@@_) {
                my $frequency = shift;
                if (       $frequency < MIN_FREQUENCY
                        || $frequency < $self->timeout()
                        || $frequency > MAX_FREQUENCY)
                {
                        return $self->{frequency};
                }
                $self->{frequency} = $frequency;
        }
        return $self->{frequency};
}

sub tos {
        my $self = shift;

        # This field is not applicable to DHCP or DNS operations.
        if (       $self->type() == $operationTypeEnum->{dns}
                || $self->type() == $operationTypeEnum->{dhcp})
        {

                # Return DEFAULT_TOS here (i.e. 0 for now; I guess it could change...)
                return DEFAULT_TOS;
        }
        if (@@_) {
                my $tos = shift;
                if ($tos < MIN_TOS || $tos > MAX_TOS) {
                        return $self->{tos};
                }
                $self->{tos} = $tos;
        }
        return $self->{tos};
}

sub source_port {
        my $self = shift;

        # This field is not applicable to DNS, DLSw, or SNA operations.
        if (
                   $self->type() == $operationTypeEnum->{dns}
                || $self->type() == $operationTypeEnum->{dlsw}
                || (       $self->protocol() > $operationProtocolEnum->{udpEcho}
                        && $self->protocol() <=
                        $operationProtocolEnum->{snaLU62EchoAppl})
            )
        {
                return DEFAULT_SPORT;
        }

        if (@@_) {
                my $sport = shift;
                if ($sport < MIN_SPORT || $sport > MAX_SPORT) {
                        return $self->{sourcePort};
                }
                $self->{sourcePort} = $sport;
        }
        return $self->{sourcePort};
}

sub target_port {
        my $self = shift;

        # This field is applicable to udpEcho, tcpConnect, and jitter operations.
        if (       $self->type() != $operationTypeEnum->{udpEcho}
                && $self->type() != $operationTypeEnum->{tcpConnect}
                && $self->type() != $operationTypeEnum->{jitter})
        {
                return DEFAULT_TPORT;
        }

        if (@@_) {
                my $tport = shift;
                if ($tport < MIN_TPORT || $tport > MAX_TPORT) {
                        return $self->{targetPort};
                }
                $self->{targetPort} = $tport;
        }
        return $self->{targetPort};
}

sub control_enabled {
        my $self = shift;

        # This field is not applicable to echo, pathEcho, dns and http operations.
        if (       $self->type() == $operationTypeEnum->{echo}
                || $self->type() == $operationTypeEnum->{pathEcho}
                || $self->type() == $operationTypeEnum->{dns}
                || $self->type() == $operationTypeEnum->{http})
        {
                return DEFAULT_CONTROL_ENABLE;
        }

        if (@@_) {
                my $control = shift;
                if ($control != TRUE && $control != FALSE) {
                        return $self->{controlEnable};
                }
                $self->{controlEnable} = $control;
        }
        return $self->{controlEnable};
}

sub admin_operation {
        my $self = shift;
        my ($val, $op);

        # This field is only applicable to http and ftp operations.
        if (       $self->type() != $operationTypeEnum->{http}
                && $self->type() != $operationTypeEnum->{ftp})
        {

                # This field has no default value.
                return;
        }
        if (@@_) {
                $val = shift;
                foreach (keys %{$adminOperationEnum}) {

                        if ($val == $adminOperationEnum->{$_}) {
                                $op = $val;
                                last;
                        }
                }

                if (!$op) {
                        return $self->{adminOperation};
                }
                $self->{adminOperation} = $op;
        }
        return $self->{adminOperation};
}

sub admin_strings {
        my $self = shift;

        # This field is only applicable to http and dhcp operations.
        if (       $self->type() != $operationTypeEnum->{http}
                && $self->type() != $operationTypeEnum->{dhcp})
        {
                return;
        }

        if (@@_) {
                my $string = shift;
                my ($i, $length, $limit);
                $i      = 0;
                $length = 0;

                # The dhcp operation only uses AdminString1.
                $limit =
                    ($self->type() == $operationTypeEnum->{http})
                    ? MAX_ADMIN_STRINGS
                    : 1;

                # This string has a cap.  If this string is longer than the max, we need
                # to chop it, and fit it into an array.

                while ($i < $limit) {
                        while ($length < length $string) {
                                push @@{$self->{adminStrings}},
                                    substr($string, $length,
                                        MAX_ADMIN_STRING_LEN);
                                $length += MAX_ADMIN_STRING_LEN;
                        }
                        $i++;
                }
        }
        return $self->{adminStrings};
}

sub admin_url {
        my $self = shift;

        # This field is only applicable to http and ftp operations.
        if (       $self->type() != $operationTypeEnum->{http}
                && $self->type() != $operationTypeEnum->{ftp})
        {
                return;
        }

        if (@@_) {
                my $url = shift;

                if (length $url > MAX_URL_LEN) {
                        return $self->{adminURL};
                }
                $self->{adminURL} = $url;
        }
        return $self->{adminURL};
}

sub admin_cache {
        my $self = shift;

        # This field is only applicable to http operations.
        if ($self->type() != $operationTypeEnum->{http}) {
                return DEFAULT_ADMIN_CACHE;
        }

        if (@@_) {
                my $cache = shift;

                if ($cache != TRUE && $cache != FALSE) {
                        return $self->{adminCache};
                }
                $self->{adminCache} = $cache;
        }
        return $self->{adminCache};
}

sub name_server {
        my $self = shift;
        my $addr;

        if ($self->type() != $operationTypeEnum->{dns}) {
                return;
        }
        if (@@_) {
                $addr = shift;
                if (!checkIPAddr($addr)) {
                        return $self->{dnsTargetAddress};
                }
                $self->{dnsTargetAddress} = $addr;
        }
        return $self->{dnsTargetAddress};
}

1;
@


1.16
log
@Fix bug in exporter.
@
text
@d2 1
a2 1
# $Id: Operation.pm,v 1.15 2001/10/04 20:21:46 jmarcus Exp $
d15 42
a56 41
    # ARG 1: String name
    # ARG 2: int type
    # ARG 3: int proto

    # This constructor creates new SAA operations.  It accepts three mandatory
    # arguments, the operation name, the operation protocol, the 
    # operation type.  Once the class is instantiated, use the accessor methods 
    # to configure the class properties.
    my ( $that, @@args ) = @@_;
    my $class = ref($that) || $that;

    if ( scalar(@@args) != 3 ) {
        croak "SAA::Operation: Insufficient arguments passed to constructor";
    }

    my $self = {
        name             => $args[0],
        type             => $operationTypeEnum->{na},
        protocol         => $operationProtocolEnum->{na},
        threshold        => DEFAULT_THRESHOLD,
        frequency        => DEFAULT_FREQUENCY,
        timeout          => DEFAULT_TIMEOUT,
        verify           => DEFAULT_VERIFY,
        tos              => DEFAULT_TOS,
        targetPort       => DEFAULT_TPORT,
        sourcePort       => DEFAULT_SPORT,
        controlEnable    => DEFAULT_CONTROL_ENABLE,
        dnsTargetAddress => undef,
        adminOperation   => undef,
        adminStrings     => undef,
        adminURL         => undef,
        adminCache       => DEFAULT_ADMIN_CACHE,
        error            => undef,
    };

    my $rc = _validateTypeProto( $args[1], $args[2] );
    return unless $rc;
    $self->{type}     = $args[1];
    $self->{protocol} = $args[2];
    bless( $self, $class );
    $self;
d60 1
a60 1
    my ( $type, $proto ) = @@_;
d62 33
a94 39
    if ( scalar(@@_) != 2 ) {
        croak
"SAA::Operation::_validateTypeProtocol: method requires two arguments";
    }

    # This is a private static method for testing whether or not the type and
    # protocol are compatible.  It returns 1 if they are, undef otherwise.

    if ( $type == $operationTypeEnum->{echo} ) {
        return
          unless ( $proto == $operationProtocolEnum->{icmpEcho}
            || $proto == $operationProtocolEnum->{snaRUEcho}
            || $proto == $operationProtocolEnum->{snaLU0EchoAppl}
            || $proto == $operationProtocolEnum->{snaLU2EchoAppl}
            || $proto == $operationProtocolEnum->{snaLU62Echo}
            || $proto == $operationProtocolEnum->{snaLU62EchoAppl} );
    }
    elsif ( $type == $operationTypeEnum->{pathEcho} ) {
        return
          unless ( $proto == $operationProtocolEnum->{icmpEcho} );
    }
    elsif ( $type == $operationTypeEnum->{tcpConnect} ) {
        return unless ( $proto == $operationProtocolEnum->{ipTcpConn} );
    }
    elsif ( $type == $operationTypeEnum->{http} ) {
        return
          unless ( $proto == $operationProtocolEnum->{httpAppl} );
    }
    elsif ( $type == $operationTypeEnum->{dns} ) {
        return
          unless ( $proto == $operationProtocolEnum->{dnsAppl} );
    }
    elsif ( $type == $operationTypeEnum->{dhcp} ) {
        return
          unless ( $proto == $operationProtocolEnum->{dhcpAppl} );
    }
    else {
        return;
    }
d96 1
a96 1
    1;
d100 1
a100 1
    my $self = shift;
d102 2
a103 2
    # Name is static once the class has been instantiated.
    return $self->{name};
d107 1
a107 1
    my $self = shift;
d109 2
a110 2
    # Type is static once the class has been instantiated.
    return $self->{type};
d114 1
a114 1
    my $self = shift;
d116 2
a117 2
    # Protocol is static once the class has been instantiated.
    return $self->{protocol};
d121 1
a121 1
    my $self = shift;
d123 10
a132 8
    # Threshold is valid for all SAA operations.
    if (@@_) {
        my $th = shift;
        if ( $th < MIN_THRESHOLD
            || $th > $self->timeout()
            || $th > MAX_THRESHOLD )
        {
            return $self->{threshold};
d134 1
a134 3
        $self->{threshold} = $th;
    }
    return $self->{threshold};
d138 1
a138 1
    my $self = shift;
d140 10
a149 8
    # Timeout is valid for all SAA operations.
    if (@@_) {
        my $timeout = shift;
        if ( $timeout < MIN_TIMEOUT
            || $timeout < $self->threshold()
            || $timeout > MAX_TIMEOUT )
        {
            return $self->{timeout};
d151 1
a151 3
        $self->{timeout} = $timeout;
    }
    return $self->{timeout};
d155 1
a155 1
    my $self = shift;
d157 10
a166 8
    # Frequency is valid for all SAA operations.
    if (@@_) {
        my $frequency = shift;
        if ( $frequency < MIN_FREQUENCY
            || $frequency < $self->timeout()
            || $frequency > MAX_FREQUENCY )
        {
            return $self->{frequency};
d168 1
a168 3
        $self->{frequency} = $frequency;
    }
    return $self->{frequency};
d172 6
a177 1
    my $self = shift;
d179 11
a189 16
    # This field is not applicable to DHCP or DNS operations.
    if ( $self->type() == $operationTypeEnum->{dns}
        || $self->type() == $operationTypeEnum->{dhcp} )
    {

        # Return DEFAULT_TOS here (i.e. 0 for now; I guess it could change...)
        return DEFAULT_TOS;
    }
    if (@@_) {
        my $tos = shift;
        if ( $tos < MIN_TOS || $tos > MAX_TOS ) {
            return $self->{tos};
        }
        $self->{tos} = $tos;
    }
    return $self->{tos};
d193 1
a193 1
    my $self = shift;
d195 20
a214 19
    # This field is not applicable to DNS, DLSw, or SNA operations.
    if (
        $self->type() == $operationTypeEnum->{dns}
        || $self->type() == $operationTypeEnum->{dlsw}
        || ( $self->protocol() > $operationProtocolEnum->{udpEcho}
            && $self->protocol() <= $operationProtocolEnum->{snaLU62EchoAppl} )
      )
    {
        return DEFAULT_SPORT;
    }

    if (@@_) {
        my $sport = shift;
        if ( $sport < MIN_SPORT || $sport > MAX_SPORT ) {
            return $self->{sourcePort};
        }
        $self->{sourcePort} = $sport;
    }
    return $self->{sourcePort};
d218 9
a226 1
    my $self = shift;
d228 8
a235 16
    # This field is applicable to udpEcho, tcpConnect, and jitter operations.
    if ( $self->type() != $operationTypeEnum->{udpEcho}
        && $self->type() != $operationTypeEnum->{tcpConnect}
        && $self->type() != $operationTypeEnum->{jitter} )
    {
        return DEFAULT_TPORT;
    }

    if (@@_) {
        my $tport = shift;
        if ( $tport < MIN_TPORT || $tport > MAX_TPORT ) {
            return $self->{targetPort};
        }
        $self->{targetPort} = $tport;
    }
    return $self->{targetPort};
d239 10
a248 1
    my $self = shift;
d250 8
a257 17
    # This field is not applicable to echo, pathEcho, dns and http operations.
    if ( $self->type() == $operationTypeEnum->{echo}
        || $self->type() == $operationTypeEnum->{pathEcho}
        || $self->type() == $operationTypeEnum->{dns}
        || $self->type() == $operationTypeEnum->{http} )
    {
        return DEFAULT_CONTROL_ENABLE;
    }

    if (@@_) {
        my $control = shift;
        if ( $control != TRUE && $control != FALSE ) {
            return $self->{controlEnable};
        }
        $self->{controlEnable} = $control;
    }
    return $self->{controlEnable};
d261 7
a267 2
    my $self = shift;
    my ( $val, $op );
d269 19
a287 24
    # This field is only applicable to http and ftp operations.
    if ( $self->type() != $operationTypeEnum->{http}
        && $self->type() != $operationTypeEnum->{ftp} )
    {

        # This field has no default value.
        return;
    }
    if (@@_) {
        $val = shift;
        foreach ( keys %{$adminOperationEnum} ) {

            if ( $val == $adminOperationEnum->{$_} ) {
                $op = $val;
                last;
            }
        }

        if ( !$op ) {
            return $self->{adminOperation};
        }
        $self->{adminOperation} = $op;
    }
    return $self->{adminOperation};
d291 1
a291 1
    my $self = shift;
d293 31
a323 29
    # This field is only applicable to http and dhcp operations.
    if ( $self->type() != $operationTypeEnum->{http}
        && $self->type() != $operationTypeEnum->{dhcp} )
    {
        return;
    }

    if (@@_) {
        my $string = shift;
        my ( $i, $length, $limit );
        $i      = 0;
        $length = 0;

        # The dhcp operation only uses AdminString1.
        $limit =
          ( $self->type() == $operationTypeEnum->{http} ) 
          ? MAX_ADMIN_STRINGS
          : 1;

        # This string has a cap.  If this string is longer than the max, we need
        # to chop it, and fit it into an array.

        while ( $i < $limit ) {
            while ( $length < length $string ) {
                push @@{ $self->{adminStrings} },
                  substr( $string, $length, MAX_ADMIN_STRING_LEN );
                $length += MAX_ADMIN_STRING_LEN;
            }
            $i++;
d325 1
a325 2
    }
    return $self->{adminStrings};
d329 1
a329 1
    my $self = shift;
d331 16
a346 16
    # This field is only applicable to http and ftp operations.
    if ( $self->type() != $operationTypeEnum->{http}
        && $self->type() != $operationTypeEnum->{ftp} )
    {
        return;
    }

    if (@@_) {
        my $url = shift;

        if ( length $url > MAX_URL_LEN ) {
            return $self->{adminURL};
        }
        $self->{adminURL} = $url;
    }
    return $self->{adminURL};
d350 6
a355 1
    my $self = shift;
d357 9
a365 14
    # This field is only applicable to http operations.
    if ( $self->type() != $operationTypeEnum->{http} ) {
        return DEFAULT_ADMIN_CACHE;
    }

    if (@@_) {
        my $cache = shift;

        if ( $cache != TRUE && $cache != FALSE ) {
            return $self->{adminCache};
        }
        $self->{adminCache} = $cache;
    }
    return $self->{adminCache};
d369 2
a370 2
    my $self = shift;
    my $addr;
d372 11
a382 11
    if ( $self->type() != $operationTypeEnum->{dns} ) {
        return;
    }
    if (@@_) {
        $addr = shift;
        if ( !checkIPAddr($addr) ) {
            return $self->{dnsTargetAddress};
        }
        $self->{dnsTargetAddress} = $addr;
    }
    return $self->{dnsTargetAddress};
@


1.15
log
@Add $Id$ CVS tags.
@
text
@d2 1
a2 1
# $Id$
d32 10
a41 10
        type             => $SAA::SAA_MIB::operationTypeEnum->{na},
        protocol         => $SAA::SAA_MIB::operationProtocolEnum->{na},
        threshold        => SAA::SAA_MIB::DEFAULT_THRESHOLD,
        frequency        => SAA::SAA_MIB::DEFAULT_FREQUENCY,
        timeout          => SAA::SAA_MIB::DEFAULT_TIMEOUT,
        verify           => SAA::SAA_MIB::DEFAULT_VERIFY,
        tos              => SAA::SAA_MIB::DEFAULT_TOS,
        targetPort       => SAA::SAA_MIB::DEFAULT_TPORT,
        sourcePort       => SAA::SAA_MIB::DEFAULT_SPORT,
        controlEnable    => SAA::SAA_MIB::DEFAULT_CONTROL_ENABLE,
d46 1
a46 1
        adminCache       => SAA::SAA_MIB::DEFAULT_ADMIN_CACHE,
d69 1
a69 1
    if ( $type == $SAA::SAA_MIB::operationTypeEnum->{echo} ) {
d71 6
a76 7
          unless ( $proto == $SAA::SAA_MIB::operationProtocolEnum->{icmpEcho}
            || $proto == $SAA::SAA_MIB::operationProtocolEnum->{snaRUEcho}
            || $proto == $SAA::SAA_MIB::operationProtocolEnum->{snaLU0EchoAppl}
            || $proto == $SAA::SAA_MIB::operationProtocolEnum->{snaLU2EchoAppl}
            || $proto == $SAA::SAA_MIB::operationProtocolEnum->{snaLU62Echo}
            || $proto ==
            $SAA::SAA_MIB::operationProtocolEnum->{snaLU62EchoAppl} );
d78 1
a78 1
    elsif ( $type == $SAA::SAA_MIB::operationTypeEnum->{pathEcho} ) {
d80 1
a80 1
          unless ( $proto == $SAA::SAA_MIB::operationProtocolEnum->{icmpEcho} );
d82 2
a83 4
    elsif ( $type == $SAA::SAA_MIB::operationTypeEnum->{tcpConnect} ) {
        return
          unless (
            $proto == $SAA::SAA_MIB::operationProtocolEnum->{ipTcpConn} );
d85 1
a85 1
    elsif ( $type == $SAA::SAA_MIB::operationTypeEnum->{http} ) {
d87 1
a87 1
          unless ( $proto == $SAA::SAA_MIB::operationProtocolEnum->{httpAppl} );
d89 1
a89 1
    elsif ( $type == $SAA::SAA_MIB::operationTypeEnum->{dns} ) {
d91 1
a91 1
          unless ( $proto == $SAA::SAA_MIB::operationProtocolEnum->{dnsAppl} );
d93 1
a93 1
    elsif ( $type == $SAA::SAA_MIB::operationTypeEnum->{dhcp} ) {
d95 1
a95 1
          unless ( $proto == $SAA::SAA_MIB::operationProtocolEnum->{dhcpAppl} );
d131 3
a133 2
        if ( $th < SAA::SAA_MIB::MIN_THRESHOLD || $th > $self->timeout()
            || $th > SAA::SAA_MIB::MAX_THRESHOLD )
d148 1
a148 1
        if ( $timeout < SAA::SAA_MIB::MIN_TIMEOUT
d150 1
a150 1
            || $timeout > SAA::SAA_MIB::MAX_TIMEOUT )
d165 1
a165 1
        if ( $frequency < SAA::SAA_MIB::MIN_FREQUENCY
d167 1
a167 1
            || $frequency > SAA::SAA_MIB::MAX_FREQUENCY )
d180 2
a181 2
    if ( $self->type() == $SAA::SAA_MIB::operationTypeEnum->{dns}
        || $self->type() == $SAA::SAA_MIB::operationTypeEnum->{dhcp} )
d185 1
a185 1
        return SAA::SAA_MIB::DEFAULT_TOS;
d189 1
a189 1
        if ( $tos < SAA::SAA_MIB::MIN_TOS || $tos > SAA::SAA_MIB::MAX_TOS ) {
d201 6
a206 5
    if ( $self->type() == $SAA::SAA_MIB::operationTypeEnum->{dns}
        || $self->type() == $SAA::SAA_MIB::operationTypeEnum->{dlsw}
        || ( $self->protocol() > $SAA::SAA_MIB::operationProtocolEnum->{udpEcho}
            && $self->protocol() <=
            $SAA::SAA_MIB::operationProtocolEnum->{snaLU62EchoAppl} ) )
d208 1
a208 1
        return SAA::SAA_MIB::DEFAULT_SPORT;
d213 1
a213 3
        if ( $sport < SAA::SAA_MIB::MIN_SPORT
            || $sport > SAA::SAA_MIB::MAX_SPORT )
        {
d225 3
a227 3
    if ( $self->type() != $SAA::SAA_MIB::operationTypeEnum->{udpEcho}
        && $self->type() != $SAA::SAA_MIB::operationTypeEnum->{tcpConnect}
        && $self->type() != $SAA::SAA_MIB::operationTypeEnum->{jitter} )
d229 1
a229 1
        return SAA::SAA_MIB::DEFAULT_TPORT;
d234 1
a234 3
        if ( $tport < SAA::SAA_MIB::MIN_TPORT
            || $tport > SAA::SAA_MIB::MAX_TPORT )
        {
d246 4
a249 4
    if ( $self->type() == $SAA::SAA_MIB::operationTypeEnum->{echo}
        || $self->type() == $SAA::SAA_MIB::operationTypeEnum->{pathEcho}
        || $self->type() == $SAA::SAA_MIB::operationTypeEnum->{dns}
        || $self->type() == $SAA::SAA_MIB::operationTypeEnum->{http} )
d251 1
a251 1
        return SAA::SAA_MIB::DEFAULT_CONTROL_ENABLE;
d256 1
a256 2
        if ( $control != SAA::SAA_MIB::TRUE && $control != SAA::SAA_MIB::FALSE )
        {
d269 2
a270 2
    if ( $self->type() != $SAA::SAA_MIB::operationTypeEnum->{http}
        && $self->type() != $SAA::SAA_MIB::operationTypeEnum->{ftp} )
d278 1
a278 1
        foreach ( keys %{$SAA::SAA_MIB::adminOperationEnum} ) {
d280 1
a280 1
            if ( $val == $SAA::SAA_MIB::adminOperationEnum->{$_} ) {
d298 2
a299 2
    if ( $self->type() != $SAA::SAA_MIB::operationTypeEnum->{http}
        && $self->type() != $SAA::SAA_MIB::operationTypeEnum->{dhcp} )
d312 3
a314 2
          ( $self->type() == $SAA::SAA_MIB::operationTypeEnum->{http} ) ?
          SAA::SAA_MIB::MAX_ADMIN_STRINGS: 1;
d321 3
a323 3
                push @@{ $self->{adminStrings} }, substr( $string, $length,
                    SAA::SAA_MIB::MAX_ADMIN_STRING_LEN );
                $length += SAA::SAA_MIB::MAX_ADMIN_STRING_LEN;
d335 2
a336 2
    if ( $self->type() != $SAA::SAA_MIB::operationTypeEnum->{http}
        && $self->type() != $SAA::SAA_MIB::operationTypeEnum->{ftp} )
d344 1
a344 1
        if ( length $url > SAA::SAA_MIB::MAX_URL_LEN ) {
d356 2
a357 2
    if ( $self->type() != $SAA::SAA_MIB::operationTypeEnum->{http} ) {
        return SAA::SAA_MIB::DEFAULT_ADMIN_CACHE;
d363 1
a363 1
        if ( $cache != SAA::SAA_MIB::TRUE && $cache != SAA::SAA_MIB::FALSE ) {
d375 1
a375 1
    if ( $self->type() != $SAA::SAA_MIB::operationTypeEnum->{dns} ) {
@


1.14
log
@Add support for the rttMonEchoAdminCache object.
@
text
@d1 3
@


1.13
log
@Coding, coding coding....
@
text
@d43 1
d323 1
a323 2
                push @@{ $self->{adminStrings} },
                  substr( $string, $length,
d352 19
@


1.12
log
@More Collector code.
@
text
@d40 3
a42 3
        httpOperation    => undef,
        httpStrings      => undef,
        httpURL          => undef,
d266 1
a266 1
sub http_operation {
d270 4
a273 2
    # This field is only applicable to http operations.
    if ( $self->type() != $SAA::SAA_MIB::operationTypeEnum->{http} ) {
d280 1
a280 1
        foreach ( keys %{$SAA::SAA_MIB::httpOperationEnum} ) {
d282 1
a282 1
            if ( $val == $SAA::SAA_MIB::httpOperationEnum->{$_} ) {
d289 1
a289 1
            return $self->{httpOperation};
d291 1
a291 1
        $self->{httpOperation} = $op;
d293 1
a293 1
    return $self->{httpOperation};
d296 1
a296 1
sub http_strings {
d299 4
a302 2
    # This field is only applicable to http operations.
    if ( $self->type() != $SAA::SAA_MIB::operationTypeEnum->{http} ) {
d308 1
a308 1
        my ( $i, $length );
d312 5
d319 2
a320 1
        while ( $i < SAA::SAA_MIB::MAX_HTTP_STRINGS ) {
d322 4
a325 3
                push @@{ $self->{httpStrings} },
                  substr( $string, $length, SAA::SAA_MIB::MAX_HTTP_STRING_LEN );
                $length += SAA::SAA_MIB::MAX_HTTP_STRING_LEN;
d330 1
a330 1
    return $self->{httpStrings};
d333 1
a333 1
sub http_url {
d336 4
a339 2
    # This field is only applicable to http operations.
    if ( $self->type() != $SAA::SAA_MIB::operationTypeEnum->{http} ) {
d347 1
a347 1
            return $self->{httpURL};
d349 1
a349 1
        $self->{httpURL} = $url;
d351 1
a351 1
    return $self->{httpURL};
@


1.11
log
@More Operation fields and code cleanup.
@
text
@d42 1
d294 1
a294 1
sub http_string {
d320 19
@


1.10
log
@The sourceAddress field does not belong here.
@
text
@d41 1
d278 1
d284 1
d291 28
@


1.9
log
@More code changes and additions.  Moved some of the more prominent
private static methods into Globals, and made them public static.
@
text
@a36 1
        sourceAddress    => undef,
@


1.8
log
@Massive OOP style changes.
@
text
@d291 17
@


1.7
log
@Added more Collector code, and cleaned up Operation some.
@
text
@a9 64
# XXX I'm thinking the majority of these constants should be moved out
# to the SAA_MIB module....

# Define global protocols
$SAA::Operation::PROTO_NA                 = 1;
$SAA::Operation::PROTO_ICMP_ECHO          = 2;
$SAA::Operation::PROTO_UDP_ECHO           = 3;
$SAA::Operation::PROTO_SNA_RU_ECHO        = 4;
$SAA::Operation::PROTO_SNA_LU0_ECHO_APPL  = 5;
$SAA::Operation::PROTO_SNA_LU2_ECHO_APPL  = 6;
$SAA::Operation::PROTO_SNA_LU62_ECHO      = 7;
$SAA::Operation::PROTO_SNA_LU62_ECHO_APPL = 8;
$SAA::Operation::PROTO_TCP_CONN           = 24;
$SAA::Operation::PROTO_HTTP_APPL          = 25;
$SAA::Operation::PROTO_DNS_APPL           = 26;
$SAA::Operation::PROTO_JITTER_APPL        = 27;
$SAA::Operation::PROTO_DLSW_APPL          = 28;
$SAA::Operation::PROTO_DHCP_APPL          = 29;
$SAA::Operation::PROTO_FTP_APPL           = 30;

# End protocol definitions

# Define global operation types
$SAA::Operation::TYPE_NA        = 0;    # Note: this is not defined in the MIB
$SAA::Operation::TYPE_ECHO      = 1;
$SAA::Operation::TYPE_PATH_ECHO = 2;
$SAA::Operation::TYPE_FILE_IO   = 3;    # NOT SUPPORTED
$SAA::Operation::TYPE_SCRIPT    = 4;    # NOT SUPPORTED
$SAA::Operation::TYPE_UDP_ECHO  = 5;
$SAA::Operation::TYPE_TCP_CONN  = 6;
$SAA::Operation::TYPE_HTTP      = 7;
$SAA::Operation::TYPE_DNS       = 8;
$SAA::Operation::TYPE_JITTER    = 9;
$SAA::Operation::TYPE_DLSW      = 10;
$SAA::Operation::TYPE_DHCP      = 11;
$SAA::Operation::TYPE_FTP       = 12;

# End type definitions

# Define global defaults
$SAA::Operation::DEFAULT_THRESHOLD      = 5000;
$SAA::Operation::DEFAULT_FREQUENCY      = 60;
$SAA::Operation::DEFAULT_TIMEOUT        = 5000;
$SAA::Operation::DEFAULT_VERIFY         = $SAA::SAA_MIB::FALSE;
$SAA::Operation::DEFAULT_TOS            = 0;
$SAA::Operation::DEFAULT_CONTROL_ENABLE = $SAA::SAA_MIB::TRUE;
$SAA::Operation::DEFAULT_SPORT          = 0;
$SAA::Operation::DEFAULT_TPORT          = 0;

# Define global limits
$SAA::Operation::MIN_THRESHOLD = 0;
$SAA::Operation::MIN_TIMEOUT   = 0;
$SAA::Operation::MIN_SPORT     = 0;
$SAA::Operation::MIN_TPORT     = 0;
$SAA::Operation::MIN_FREQUENCY = 0;
$SAA::Operation::MAX_FREQUENCY = 604800;
$SAA::Operation::MAX_TIMEOUT   = 604800000;
$SAA::Operation::MAX_THRESHOLD = 2147483647;
$SAA::Operation::CONTROL       = 0;
$SAA::Operation::MAX_SPORT     = 65536;
$SAA::Operation::MAX_TPORT     = 65536;

# End limit definitions

d29 12
a40 12
        type             => $SAA::Operation::TYPE_NA,
        protocol         => $SAA::Operation::PROTO_NA,
        threshold        => $SAA::Operation::DEFAULT_THRESHOLD,
        frequency        => $SAA::Operation::DEFAULT_FREQUENCY,
        timeout          => $SAA::Operation::DEFAULT_TIMEOUT,
        verify           => $SAA::Operation::DEFAULT_VERIFY,
        tos              => $SAA::Operation::DEFAULT_TOS,
        targetPort       => $SAA::Operation::DEFAULT_TPORT,
        sourceAddress    => '',
        sourcePort       => $SAA::Operation::DEFAULT_SPORT,
        controlEnable    => $SAA::Operation::DEFAULT_CONTROL_ENABLE,
        dnsTargetAddress => '',
d56 5
d64 1
a64 1
    if ( $type == $SAA::Operation::TYPE_ECHO ) {
d66 7
a72 12
          unless ( $proto == $SAA::Operation::PROTO_ICMP_ECHO
            || $proto == $SAA::Operation::PROTO_SNA_RU_ECHO
            || $proto == $SAA::Operation::PROTO_SNA_LU0_ECHO_APPL
            || $proto == $SAA::Operation::PROTO_SNA_LU2_ECHO_APPL
            || $proto == $SAA::Operation::PROTO_SNA_LU62_ECHO
            || $proto == $SAA::Operation::PROTO_SNA_LU62_ECHO_APPL );
    }
    elsif ( $type == $SAA::Operation::TYPE_PATH_ECHO ) {
        return unless ( $proto == $SAA::Operation::PROTO_ICMP_ECHO );
    }
    elsif ( $type == $SAA::Operation::TYPE_TCP_CONN ) {
        return unless ( $proto == $SAA::Operation::PROTO_TCP_CONN );
d74 3
a76 2
    elsif ( $type == $SAA::Operation::TYPE_HTTP ) {
        return unless ( $proto == $SAA::Operation::PROTO_HTTP );
d78 4
a81 2
    elsif ( $type == $SAA::Operation::TYPE_DNS ) {
        return unless ( $proto == $SAA::Operation::PROTO_DNS );
d83 11
a93 2
    elsif ( $type == $SAA::Operation::TYPE_DHCP ) {
        return unless ( $proto == $SAA::Operation::PROTO_DHCP );
d129 2
a130 2
        if ( $th < $SAA::Operation::MIN_THRESHOLD || $th > $self->timeout()
            || $th > $SAA::Operation::MAX_THRESHOLD )
d145 1
a145 1
        if ( $timeout < $SAA::Operation::MIN_TIMEOUT
d147 1
a147 1
            || $timeout > $SAA::Operation::MAX_TIMEOUT )
d162 1
a162 1
        if ( $frequency < $SAA::Operation::MIN_FREQUENCY
d164 1
a164 1
            || $frequency > $SAA::Operation::MAX_FREQUENCY )
d177 2
a178 2
    if ( $self->type() == $SAA::Operation::TYPE_DNS
        || $self->type() == $SAA::Operation::TYPE_DHCP )
d182 1
a182 1
        return $SAA::Operation::DEFAULT_TOS;
d186 1
a186 3
        if ( $tos < $SAA::Operation::MIN_TOS
            || $tos > $SAA::Operation::MAX_TOS )
        {
d198 5
a202 5
    if ( $self->type() == $SAA::Operation::TYPE_DNS
        || $self->type() == $SAA::Operations::TYPE_DLSW
        || ( $self->protocol() > $SAA::Operation::PROTO_UDP_ECHO
            && $self->protocol() <= $SAA::Operation::PROTO_SNA_LU62_ECHO_APPL )
      )
d204 1
a204 1
        return $SAA::Operation::DEFAULT_SPORT;
d209 2
a210 2
        if ( $sport < $SAA::Operation::MIN_SPORT
            || $sport > $SAA::Operation::MAX_SPORT )
d223 3
a225 3
    if ( $self->type() != $SAA::Operation::TYPE_UDP_ECHO
        && $self->type() != $SAA::Operation::TYPE_TCP_CONN
        && $self->type() != $SAA::Operation::TYPE_JITTER )
d227 1
a227 1
        return $SAA::Operation::DEFAULT_TPORT;
d232 2
a233 2
        if ( $tport < $SAA::Operation::MIN_TPORT
            || $tport > $SAA::Operation::MAX_TPORT )
d246 4
a249 4
    if ( $self->type() == $SAA::Operation::TYPE_ECHO
        || $self->type() == $SAA::Operation::TYPE_PATH_ECHO
        || $self->type() == $SAA::Operation::TYPE_DNS
        || $self->type() == $SAA::Operation::TYPE_HTTP )
d251 1
a251 1
        return $SAA::Operation::DEFAULT_CONTROL_ENABLE;
d256 1
a256 2
        if ( $control != $SAA::SAA_MIB::TRUE
            && $control != $SAA::SAA_MIB::FALSE )
d270 1
a270 1
    if ( $self->type() != $SAA::Operation::TYPE_HTTP ) {
@


1.6
log
@Add error field to SAA::Operation.
@
text
@d10 3
d64 1
d105 1
d110 1
a110 1
	return unless $rc;
d229 2
a230 2
    if ( $self->{type} == $SAA::Operation::TYPE_DNS
        || $self->{type} == $SAA::Operation::TYPE_DHCP )
d248 1
a248 1
sub sourcePort {
d252 4
a255 4
    if ( $self->{type} == $SAA::Operation::TYPE_DNS
        || $self->{type} == $SAA::Operations::TYPE_DLSW
        || ( $self->{protocol} > $SAA::Operation::PROTO_UDP_ECHO
            && $self->{protocol} <= $SAA::Operation::PROTO_SNA_LU62_ECHO_APPL )
d273 1
a273 1
sub targetPort {
d277 3
a279 3
    if ( $self->{type} != $SAA::Operation::TYPE_UDP_ECHO
        && $self->{type} != $SAA::Operation::TYPE_TCP_CONN
        && $self->{type} != $SAA::Operation::TYPE_JITTER )
d300 4
a303 4
    if ( $self->{type} == $SAA::Operations::TYPE_ECHO
        || $self->{type} == $SAA::Operations::TYPE_PATH_ECHO
        || $self->{type} == $SAA::Operations::TYPE_DNS
        || $self->{type} == $SAA::Operations::TYPE_HTTP )
d305 1
a305 1
        return $SAA::Operations::DEFAULT_CONTROL_ENABLE;
d318 26
@


1.5
log
@Fixed the control_enable method to handle illegal operations.  Also controlEnabled->controlEnable.
@
text
@d77 3
a79 3
# arguments, the operation name, the operation protocol, the operation type.  
    # Once the class is instantiated, use the accessor methods to configure the 
    # class properties.
d101 1
d105 1
a105 1
    return unless $rc;
@


1.4
log
@Added some comments to explain what arguments are required and in what
order.
@
text
@d292 20
a311 2
    if (@@_) { $self->{controlEnabled} = shift; }
    return $self->{controlEnabled};
@


1.3
log
@Added a croak to the constructor if an insufficient number of arguments
is passed.
@
text
@d72 4
d84 1
a84 1
		croak "SAA::Operation: Insufficient arguments passed to constructor";
d291 3
a293 3
	my $self = shift;
	if (@@_) { $self->{controlEnabled} = shift;}
	return $self->{controlEnabled};
@


1.2
log
@
Created a setSAAObject to create INSERT Statments for our Database.  It still does actually connect to the database but it will print the query it would create.
@
text
@d8 1
d80 1
a80 1
        return;
@


1.1
log
@Initial import into CVS.
@
text
@d285 6
@

