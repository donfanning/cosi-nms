head	1.22;
access;
symbols;
locks; strict;
comment	@# @;


1.22
date	2003.09.01.19.45.54;	author jmarcus;	state Exp;
branches;
next	1.21;

1.21
date	2003.09.01.11.57.30;	author knail1;	state Exp;
branches;
next	1.20;

1.20
date	2003.09.01.11.06.26;	author knail1;	state Exp;
branches;
next	1.19;

1.19
date	2003.08.31.22.19.34;	author jmarcus;	state Exp;
branches;
next	1.18;

1.18
date	2001.12.17.05.46.47;	author knail1;	state Exp;
branches;
next	1.17;

1.17
date	2001.12.03.06.25.01;	author jmarcus;	state Exp;
branches;
next	1.16;

1.16
date	2001.10.04.20.21.46;	author jmarcus;	state Exp;
branches;
next	1.15;

1.15
date	2001.10.04.05.42.14;	author jmarcus;	state Exp;
branches;
next	1.14;

1.14
date	2001.10.04.02.26.22;	author jmarcus;	state Exp;
branches;
next	1.13;

1.13
date	2001.09.26.16.57.41;	author jmarcus;	state Exp;
branches;
next	1.12;

1.12
date	2001.09.26.06.23.19;	author jmarcus;	state Exp;
branches;
next	1.11;

1.11
date	2001.09.25.22.47.35;	author jmarcus;	state Exp;
branches;
next	1.10;

1.10
date	2001.09.25.21.54.10;	author jmarcus;	state Exp;
branches;
next	1.9;

1.9
date	2001.09.25.17.05.35;	author jmarcus;	state Exp;
branches;
next	1.8;

1.8
date	2001.09.19.05.26.32;	author jmarcus;	state Exp;
branches;
next	1.7;

1.7
date	2001.09.18.08.07.48;	author jmarcus;	state Exp;
branches;
next	1.6;

1.6
date	2001.09.18.08.02.04;	author jmarcus;	state Exp;
branches;
next	1.5;

1.5
date	2001.09.17.05.48.23;	author jmarcus;	state Exp;
branches;
next	1.4;

1.4
date	2001.09.16.21.21.25;	author jmarcus;	state Exp;
branches;
next	1.3;

1.3
date	2001.09.10.22.13.58;	author jmarcus;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.10.03.55.01;	author jmarcus;	state Exp;
branches;
next	1.1;

1.1
date	2001.09.09.22.55.10;	author jmarcus;	state Exp;
branches;
next	;


desc
@@


1.22
log
@Add a constant for ADMIN_TAG and avoid using a hard-coded string in
Collector.pm.
@
text
@#
# $Id: Collector.pm,v 1.21 2003/09/01 11:57:30 knail1 Exp $
#
package SAA::Collector;

use strict;
require 5.002;
use lib qw(..);    # XXX This is for testing only.
use SNMP;
use SAA::Globals;
use SAA::SAA_MIB;
use Carp;

sub new {

        # ARG 1: String name
        # ARG 2: SAA::Source source
        # ARG 3: SAA::Operation operation
        # ARG 4: (optional) SAA::Target target
        my ($that, @@args) = @@_;
        my $class = ref($that) || $that;

        if (scalar(@@args) < 3 || scalar(@@args) > 4) {
                croak
                    "SAA::Collector: Wrong number of arguments passed to constructor";
        }

        my $self = {
                name          => $args[0],
                id            => undef,
                source        => $args[1],
                operation     => $args[2],
                target        => undef,
                startTime     => DEFAULT_START_TIME,
                life          => DEFAULT_LIFE,
                writeNVRAM    => FALSE,
                historyFilter => $historyFilterEnum->{none},
                error         => undef,
        };

        my $rc = _needTarget($self->{operation}->type());
        if (scalar(@@args) == 4 && $rc) {
                $self->{target} = $args[3];
        } elsif (scalar(@@args) < 4 && $rc) {
                croak
                    "SAA::Collector: The specified operation requires a target argument";
        }

        #bugfix for proto support
        #values stored in SAA::Operation's operation for protocol are
        #numerical while values stored in SAA::Source's list of supported
        #protocols are textual as per operationProtocolEnum
        #FIX:feeding SAA::Source's object textual info after converting numerical
        #info from SAA::Operations object.
        # 12/16/2001 knail1

        my %operationProtocolEnum_rev = reverse %$operationProtocolEnum;
        my $protocol_textual          =
            $operationProtocolEnum_rev{$self->{operation}->{protocol}};

        if (!$self->{source}->protocol_supported($protocol_textual)) {
                croak
                    "SAA::Collector: The specified protocol is not supported by this source router";
        }

        #bugfix for type support: same problem as protocol entry, similar fix:
        # 12/16/2001 knail1
        my %operationTypeEnum_rev = reverse %$operationTypeEnum;
        my $type_textual = $operationTypeEnum_rev{$self->{operation}->{type}};

        if (!$self->{source}->type_supported($type_textual)) {
                croak
                    "SAA::Collector: The specified RTT type is not supported by this source router";
        }
        bless($self, $class);
        $self;
}

sub _needTarget {

        if (scalar(@@_) != 1) {
                croak
                    "SAA::Collector::_needTarget: method requires one argument";
        }

        # This is a private static method to determine if a given operation type
        # needs a target.  HTTP, DNS, FTP and DHCP operations do not need targets.
        my $type = shift;

        if (       $type == $operationTypeEnum->{dns}
                || $type == $operationTypeEnum->{http}
                || $type == $operationTypeEnum->{dhcp}
                || $type == $operationTypeEnum->{ftp})
        {
                return 0;
        }

        1;
}

sub source {
        my $self = shift;
        return $self->{source};
}

sub target {
        my $self = shift;
        return $self->{target};
}

sub name {
        my $self = shift;
        return $self->{name};
}

sub id {
        my $self = shift;
        my ($override);

        if (@@_) { $override = shift; }

        if (!$self->{id} || $override) {

                # Don't calculate id if it's already set or unless we're forced
                # to (by setting $override to 1).
                srand(time ^ $$);    # We don't need the best seed.
                $self->{id} = int(rand 65535) + 1;

        }
        return $self->{id};
}

sub write_nvram {
        my $self = shift;
        if (@@_) {
                my $val = shift;
                if ($val != TRUE && $val != FALSE) {
                        return $self->{writeNVRAM};
                }
                $self->{writeNVRAM} = $val;
        }
        return $self->{writeNVRAM};
}

sub history_filter {
        my $self = shift;
        my $filter;
        if (@@_) {
                my $val = shift;
                foreach (keys %{$historyFilterEnum}) {

                        if ($val == $historyFilterEnum->{$_}) {
                                $filter = $val;
                                last;
                        }
                }

                if (!$filter) {
                        return $self->{historyFilter};
                }
                $self->{historyFilter} = $filter;
        }
        return $self->{historyFilter};
}

sub life {
        my $self = shift;
        if (@@_) {
                my $duration = shift;
                if ($duration < MIN_LIFE || $duration > MAX_LIFE) {
                        return $self->{life};
                } else {
                        $self->{life} = $duration;
                }
        }
        return $self->{life};
}

sub start_time {
        my $self = shift;

        # Since this objet represents TimeTicks, it can have pretty much any range.
        # We cast the value to an int which should make things safe.
        if (@@_) {
                my $time = shift;
                if ($time < 0) {    # We can't time travel.
                        return DEFAULT_START_TIME;
                }
                $self->{startTime} = int($time);
        }
        return $self->{startTime};
}

sub error {
        my $self = shift;
        if (@@_) { $self->{error} = shift; }
        return $self->{error};
}

sub install {

        # This method installs the collector on the source router.  It
        # assumes that the source has been successfully learned.
        my $self = shift;
        my ($source, $target, $operation, $id, $sess);

        $source = $self->source();
        $target = $self->target();
        $id     = $self->id();
        my $doWeNeedTargetPort        = undef;
        my $doWeNotNeedSourcePort     = undef;
        my $ControlEnableNotNecessary = undef;

        if ($source->status() != HOST_UP_SNMP) {
                $self->error( "Status for host "
                            . $source->name()
                            . " indicates it is not SNMP reachable");
                return;
        }

        # A start time of 0 (the current default) is invalid.  A positive start time
        # must be specified in order for the collector to run.
        if ($self->start_time() == DEFAULT_START_TIME) {
                $self->error("Start time has not been set");
                return;
        }

        # For now, we use the read-only community string.  We'll change over
        # to read-write when we do the actual configuration.
        $sess = new SNMP::Session(
                DestHost  => $source->addr(),
                Community => $source->read_community(),
                Version   => $source->snmp_version(),
        );

        # We need to determine if the given $id is already in use on the
        # source router.  We will loop ten times or until we find a free
        # row id.
        my $i;
        for ($i = 0 ; $i < 10 ; $i++) {
                my $val = $sess->get($rttMonCtrlAdminStatus . '.' . $id);

                #last if ( $sess->{ErrorNum} ); <----

                last if ($val eq 'NOSUCHINSTANCE');

                #bugfix: $sess->ErrorNum returns 0 for each query on non-extistant
                #row. thus we need to exit out of loop using something else like $val
                # knail1 12/16/2001
                $id = $self->id(1);    # Force a new id to be generated.
        }

        # This really shouldn't happen.
        if ($i == 10) {
                $self->error("Unable to find a free row id after ten tries");
                return;
        }

        # Now that we have a valid row id, we can do the actual collector setup.
        $sess = new SNMP::Session(
                DestHost  => $source->addr(),
                Community => $source->write_community(),
                Version   => $source->snmp_version(),
        );

        # We will use the createAndWait method.
        $sess->set(
                new SNMP::Varbind(
                        [
                                $rttMonCtrlAdminStatus,          $id,
                                $rowStatusEnum->{createAndWait}, 'INTEGER'
                        ]
                )
        );

        if ($sess->{ErrorNum}) {
                $self->error("Failed to set row status");
                return;
        }
        my $varlist = new SNMP::VarList(

                #below: fixing calls to pull $operation data from $self instead of attempting locally
                # old:  $operation->protocol
                # new: $self->{operation}->{protocol}
                #knail1 12.16.2001
                [
                        $rttMonCtrlAdminRttType,    $id,
                        $self->{operation}->{type}, 'INTEGER'
                ],
                [
                        $rttMonEchoAdminProtocol,       $id,
                        $self->{operation}->{protocol}, 'INTEGER'
                ],
                [
                        $rttMonEchoAdminTOS, $id, $self->{operation}->tos(),
                        'INTEGER'
                ],
                [$rttMonCtrlAdminTag, $id, ADMIN_TAG, 'OCTETSTR']
        );

        # Add objects that may be undef for certain operations.

        #----
        if ($target) {
                push @@{$varlist},
                    [
                        $rttMonEchoAdminTargetAddress, $id,
                        pack('H8', addrToHexStr($target->addr())), 'OCTETSTR'
                    ];
        }

        #----
        if ($self->{operation}->{type} == $operationTypeEnum->{http}) {
                [
                        $rttMonEchoAdminCache,             $id,
                        $self->{operation}->admin_cache(), 'INTEGER'
                ];
        }

        #----
        #	rttMonEchoAdminTargetPort OBJECT-TYPE
        #		DESCRIPTION    "This object represents the target's port number. This
        #       object is applicable to udpEcho, tcpConnect and jitter probes."
        $doWeNeedTargetPort =
            ($self->{operation}->{type} == $operationTypeEnum->{udpEcho}
                    || $self->{operation}->{type} ==
                    $operationTypeEnum->{tcpConnect}
                    || $self->{operation}->{type} ==
                    $operationTypeEnum->{jitter});

        if ($doWeNeedTargetPort) {
                [
                        $rttMonEchoAdminTargetPort,        $id,
                        $self->{operation}->target_port(), 'INTEGER'
                ];
        }

        #----
        #rttMonEchoAdminSourcePort OBJECT-TYPE
        #         port allocated by the system. This object is applicable
        #         to all probes except dns, dlsw and sna."

        $doWeNotNeedSourcePort = (

                #if any of the following is true, then we dont need src port
                $self->{operation}->{type} == $operationTypeEnum->{dns}
                    || $self->{operation}->{type} == $operationTypeEnum->{dlsw}
                    || $self->{operation}->{type} == $operationTypeEnum->{sna}
        );
        if (!$doWeNotNeedSourcePort) {
                [
                        $rttMonEchoAdminSourcePort,        $id,
                        $self->{operation}->source_port(), 'INTEGER'
                ];
        }

        #----
        #rttMonEchoAdminControlEnable OBJECT-TYPE
        #        sent by the source router. This object is not applicable to
        #        echo, pathEcho, dns and http probes."
        $ControlEnableNotNecessary =
            (          $self->{operation}->{type} == $operationTypeEnum->{echo}
                    || $self->{operation}->{type} ==
                    $operationTypeEnum->{pathEcho}
                    || $self->{operation}->{type} == $operationTypeEnum->{dns}
                    || $self->{operation}->{type} ==
                    $operationTypeEnum->{http});
        if (!$ControlEnableNotNecessary) {
                [
                        $rttMonEchoAdminControlEnable,         $id,
                        $self->{operation}->control_enabled(), 'INTEGER'
                ];
        }

        #----
        if ($self->{operation}->name_server()) {
                push @@{$varlist},
                    [
                        $rttMonEchoAdminNameServer,
                        $id,
                        pack(
                                'H8',
                                &addrToHexStr(
                                        $self->{operation}->name_server()
                                )
                        ),
                        'OCTETSTR'
                    ];
        }

        #----
        if ($self->{operation}->admin_operation()) {
                push @@{$varlist},
                    [
                        $rttMonEchoAdminOperation,             $id,
                        $self->{operation}->admin_operation(), 'INTEGER'
                    ];
        }

        #----
        if ($self->{operation}->admin_strings()) {
                my $i;
                for (
                        $i = 0 ;
                        $i < scalar(@@{$self->{operation}->admin_strings()}) ;
                        $i++
                    )
                {
                        if ($self->{operation}->admin_strings()->[$i]) {
                                my $var = "rttMonEchoAdminString" . ($i + 1);
                                no strict
                                    'refs';  # We need to do this to allow $$var
                                push @@{$varlist},
                                    [
                                        $$var,
                                        $id,
                                        $self->{operation}->admin_strings()
                                            ->[$i],
                                        'OCTSTR'
                                    ];
                        }
                }
        }

        #----
        if ($self->{operation}->admin_url()) {
                push @@{$varlist},
                    [
                        $rttMonEchoAdminURL,             $id,
                        $self->{operation}->admin_url(), 'OCTETSTR'
                    ];
        }

##test: leaving test code in module as this would be used
        # to fix the snmp set failure bug.
        #foreach (@@$varlist)	{
        #	my $tmp = $_;
        #	foreach (@@$tmp){
        #	chomp;
        #	print $_." ";
        #			}
        #	print "\n";
        #			}
##end_test

        # Set the objects on the source router.
        $sess->set($varlist);

        if ($sess->{ErrorNum}) {
                $self->error("Failed to set collector");
                return;
        }

        $varlist = new SNMP::VarList(
                [$rttMonScheduleAdminRttLife, $id, $self->life(), 'INTEGER'],
                [
                        $rttMonScheduleAdminRttStartTime, $id,
                        $self->start_time(),              'TICKS'
                ],
                [
                        $rttMonHistoryAdminFilter, $id,
                        $self->history_filter(),   'INTEGER'
                ],
                [$rttMonCtrlAdminNvgen, $id, $self->write_nvram(), 'INTEGER'],
                [
                        $rttMonCtrlAdminStatus,   $id,
                        $rowStatusEnum->{active}, 'INTEGER'
                ]
        );

        # Turn it on!
        $sess->set($varlist);

        if ($sess->{ErrorNum}) {
                $self->error("Failed to start collector");
                return;
        }

        1;
}

sub uninstall {
        my $self = shift;

        # Remove the collector by setting rttMonCtrlAdminStatus to destroy(6).
        if (!$self->id()) {
                $self->error("Collector id is not set");
                return;
        }

        my $source = $self->source();

        my $sess = new SNMP::Session(
                DestHost  => $source->addr(),
                Community => $source->write_community(),
                Version   => $source->snmp_version(),
        );

        $sess->set(
                new SNMP::Varbind(
                        [
                                $rttMonCtrlAdminStatus,    $self->id(),
                                $rowStatusEnum->{destroy}, 'INTEGER'
                        ]
                )
        );

        if ($sess->{ErrorNum}) {
                $self->error("Failed to uninstall collector");
                return;
        }

        1;
}

1;
@


1.21
log
@fixed a bunch of bugs
@
text
@d2 1
a2 1
# $Id: Collector.pm,v 1.20 2003/09/01 11:06:26 knail1 Exp $
d16 59
a74 59
    # ARG 1: String name
    # ARG 2: SAA::Source source
    # ARG 3: SAA::Operation operation
    # ARG 4: (optional) SAA::Target target
    my ( $that, @@args ) = @@_;
    my $class = ref($that) || $that;

    if ( scalar(@@args) < 3 || scalar(@@args) > 4 ) {
        croak "SAA::Collector: Wrong number of arguments passed to constructor";
    }

    my $self = {
        name          => $args[0],
        id            => undef,
        source        => $args[1],
        operation     => $args[2],
        target        => undef,
        startTime     => DEFAULT_START_TIME,
        life          => DEFAULT_LIFE,
        writeNVRAM    => FALSE,
        historyFilter => $historyFilterEnum->{none},
        error         => undef,
    };

    my $rc = _needTarget( $self->{operation}->type() );
    if ( scalar(@@args) == 4 && $rc ) {
        $self->{target} = $args[3];
    }
    elsif ( scalar(@@args) < 4 && $rc ) {
        croak
          "SAA::Collector: The specified operation requires a target argument";
    }

    #bugfix for proto support
    #values stored in SAA::Operation's operation for protocol are
    #numerical while values stored in SAA::Source's list of supported
    #protocols are textual as per operationProtocolEnum
    #FIX:feeding SAA::Source's object textual info after converting numerical
    #info from SAA::Operations object.
    # 12/16/2001 knail1

    my %operationProtocolEnum_rev = reverse %$operationProtocolEnum;
    my $protocol_textual          =
      $operationProtocolEnum_rev{ $self->{operation}->{protocol} };

    if ( !$self->{source}->protocol_supported($protocol_textual) ) {
        croak
"SAA::Collector: The specified protocol is not supported by this source router";
    }

    #bugfix for type support: same problem as protocol entry, similar fix:
    # 12/16/2001 knail1
    my %operationTypeEnum_rev = reverse %$operationTypeEnum;
    my $type_textual = $operationTypeEnum_rev{ $self->{operation}->{type} };

    if ( !$self->{source}->type_supported($type_textual) ) {
        croak
"SAA::Collector: The specified RTT type is not supported by this source router";
    }
d124 4
a127 4
        # Don't calculate id if it's already set or unless we're forced
        # to (by setting $override to 1).
        srand( time ^ $$ );    # We don't need the best seed.
        $self->{id} = int( rand 65535 ) + 1;
d129 2
a130 2
    }
    return $self->{id};
d202 135
a336 178
    # This method installs the collector on the source router.  It 
    # assumes that the source has been successfully learned.
    my $self = shift;
    my ( $source, $target, $operation, $id, $sess );

    $source = $self->source();
    $target = $self->target();
    $id     = $self->id();
	my $doWeNeedTargetPort = undef;
	my $doWeNotNeedSourcePort = undef;
	my $ControlEnableNotNecessary = undef;

    if ( $source->status() != HOST_UP_SNMP ) {
        $self->error( "Status for host "
            . $source->name()
            . " indicates it is not SNMP reachable" );
        return;
    }

    # A start time of 0 (the current default) is invalid.  A positive start time
    # must be specified in order for the collector to run.
    if ( $self->start_time() == DEFAULT_START_TIME ) {
        $self->error("Start time has not been set");
        return;
    }

    # For now, we use the read-only community string.  We'll change over
    # to read-write when we do the actual configuration.
    $sess = new SNMP::Session(
        DestHost  => $source->addr(),
        Community => $source->read_community(),
        Version   => $source->snmp_version(),
    );

    # We need to determine if the given $id is already in use on the 
    # source router.  We will loop ten times or until we find a free 
    # row id.
    my $i;
    for ( $i = 0 ; $i < 10 ; $i++ ) {
        my $val = $sess->get( $rttMonCtrlAdminStatus . '.' . $id );

        #last if ( $sess->{ErrorNum} ); <----

        last if ( $val eq 'NOSUCHINSTANCE' );

        #bugfix: $sess->ErrorNum returns 0 for each query on non-extistant
        #row. thus we need to exit out of loop using something else like $val
        # knail1 12/16/2001
        $id = $self->id(1);    # Force a new id to be generated.
    }

    # This really shouldn't happen.
    if ( $i == 10 ) {
        $self->error("Unable to find a free row id after ten tries");
        return;
    }

    # Now that we have a valid row id, we can do the actual collector setup.
    $sess = new SNMP::Session(
        DestHost  => $source->addr(),
        Community => $source->write_community(),
        Version   => $source->snmp_version(),
    );

    # We will use the createAndWait method.
    $sess->set(
        new SNMP::Varbind(
            [
                $rttMonCtrlAdminStatus,          $id,
                $rowStatusEnum->{createAndWait}, 'INTEGER'
            ]
          )
    );

    if ( $sess->{ErrorNum} ) {
        $self->error("Failed to set row status");
        return;
    }
    my $varlist = new SNMP::VarList(

        #below: fixing calls to pull $operation data from $self instead of attempting locally
        # old:  $operation->protocol
        # new: $self->{operation}->{protocol}
        #knail1 12.16.2001
        [ $rttMonCtrlAdminRttType, $id, $self->{operation}->{type}, 'INTEGER' ],
        [
            $rttMonEchoAdminProtocol,       $id,
            $self->{operation}->{protocol}, 'INTEGER'
        ],
        [ $rttMonEchoAdminTOS, $id, $self->{operation}->tos(), 'INTEGER' ],
		[ $rttMonCtrlAdminTag, $id, "saaconfig" , 'OCTETSTR' ]
    );

    # Add objects that may be undef for certain operations.

#----
    if ($target) {
        push @@{$varlist},
          [
            $rttMonEchoAdminTargetAddress,   $id,
            pack ('H8', &addrToHexStr($target->addr())), 'OCTETSTR'
          ];
    }
#----
	if ($self->{operation}->{type} == $operationTypeEnum->{http}) {
        [
            $rttMonEchoAdminCache,             $id,
            $self->{operation}->admin_cache(), 'INTEGER'
        ];
	}
#----
#	rttMonEchoAdminTargetPort OBJECT-TYPE
#		DESCRIPTION    "This object represents the target's port number. This
#       object is applicable to udpEcho, tcpConnect and jitter probes."
	$doWeNeedTargetPort = ( 
				$self->{operation}->{type} == $operationTypeEnum->{udpEcho}  ||
				$self->{operation}->{type} == $operationTypeEnum->{tcpConnect} ||
				$self->{operation}->{type} == $operationTypeEnum->{jitter} 
						);

	if ($doWeNeedTargetPort) {
        [
            $rttMonEchoAdminTargetPort,        $id,
            $self->{operation}->target_port(), 'INTEGER'
        ];
	}

#----
#rttMonEchoAdminSourcePort OBJECT-TYPE
#         port allocated by the system. This object is applicable 
#         to all probes except dns, dlsw and sna."

	$doWeNotNeedSourcePort = (
	#if any of the following is true, then we dont need src port
				$self->{operation}->{type} == $operationTypeEnum->{dns}  ||
				$self->{operation}->{type} == $operationTypeEnum->{dlsw} ||
				$self->{operation}->{type} == $operationTypeEnum->{sna} 
						);
	if (!$doWeNotNeedSourcePort) {
        [
            $rttMonEchoAdminSourcePort,        $id,
            $self->{operation}->source_port(), 'INTEGER'
        ];
	}
#----
#rttMonEchoAdminControlEnable OBJECT-TYPE
#        sent by the source router. This object is not applicable to 
#        echo, pathEcho, dns and http probes."
	$ControlEnableNotNecessary = (
				$self->{operation}->{type} == $operationTypeEnum->{echo}  ||
				$self->{operation}->{type} == $operationTypeEnum->{pathEcho} ||
				$self->{operation}->{type} == $operationTypeEnum->{dns} || 
				$self->{operation}->{type} == $operationTypeEnum->{http} 
					);
	if (!$ControlEnableNotNecessary) {
        [
            $rttMonEchoAdminControlEnable,         $id,
            $self->{operation}->control_enabled(), 'INTEGER'
        ];
	}

#----
    if ( $self->{operation}->name_server() ) {
        push @@{$varlist},
          [
            $rttMonEchoAdminNameServer,                        $id,
            pack ('H8', &addrToHexStr($self->{operation}->name_server())), 'OCTETSTR'
          ];
    }

#----
    if ( $self->{operation}->admin_operation() ) {
        push @@{$varlist},
          [
            $rttMonEchoAdminOperation,             $id,
            $self->{operation}->admin_operation(), 'INTEGER'
          ];
    }
d338 64
a401 2
#----
    if ( $self->{operation}->admin_strings() ) {
d425 8
a432 9

#----
    if ( $self->{operation}->admin_url() ) {
        push @@{$varlist},
          [
            $rttMonEchoAdminURL,             $id,
            $self->{operation}->admin_url(), 'OCTETSTR'
          ];
    }
d446 2
a447 2
    # Set the objects on the source router.
    $sess->set($varlist);
@


1.20
log
@fixed a bunch of bugs
@
text
@d2 1
a2 1
# $Id: Collector.pm,v 1.19 2003/08/31 22:19:34 jmarcus Exp $
a15 1
<<<<<<< Collector.pm
a74 63
=======
        # ARG 1: String name
        # ARG 2: SAA::Source source
        # ARG 3: SAA::Operation operation
        # ARG 4: (optional) SAA::Target target
        my ($that, @@args) = @@_;
        my $class = ref($that) || $that;

        if (scalar(@@args) < 3 || scalar(@@args) > 4) {
                croak
                    "SAA::Collector: Wrong number of arguments passed to constructor";
        }

        my $self = {
                name          => $args[0],
                id            => undef,
                source        => $args[1],
                operation     => $args[2],
                target        => undef,
                startTime     => DEFAULT_START_TIME,
                life          => DEFAULT_LIFE,
                writeNVRAM    => FALSE,
                historyFilter => $historyFilterEnum->{none},
                startTime     => DEFAULT_START_TIME,
                error         => undef,
        };

        my $rc = _needTarget($self->{operation}->type());
        if (scalar(@@args) == 4 && $rc) {
                $self->{target} = $args[3];
        } elsif (scalar(@@args) < 4 && $rc) {
                croak
                    "SAA::Collector: The specified operation requires a target argument";
        }

        #bugfix for proto support
        #values stored in SAA::Operation's operation for protocol are
        #numerical while values stored in SAA::Source's list of supported
        #protocols are textual as per operationProtocolEnum
        #FIX:feeding SAA::Source's object textual info after converting numerical
        #info from SAA::Operations object.
        # 12/16/2001 knail1

        my %operationProtocolEnum_rev = reverse %$operationProtocolEnum;
        my $protocol_textual          =
            $operationProtocolEnum_rev{$self->{operation}->{protocol}};

        if (!$self->{source}->protocol_supported($protocol_textual)) {
                croak
                    "SAA::Collector: The specified protocol is not supported by this source router";
        }

        #bugfix for type support: same problem as protocol entry, similar fix:
        # 12/16/2001 knail1
        my %operationTypeEnum_rev = reverse %$operationTypeEnum;
        my $type_textual = $operationTypeEnum_rev{$self->{operation}->{type}};

        if (!$self->{source}->type_supported($type_textual)) {
                croak
                    "SAA::Collector: The specified RTT type is not supported by this source router";
        }
>>>>>>> 1.19

a123 1
<<<<<<< Collector.pm
a128 1
# IMPORTANT: need to ensure that this ID is not already present in router knail1 09/03
a130 8
=======
                # Don't calculate id if it's already set or unless we're forced
                # to (by setting $override to 1).
                srand(time ^ $$);    # We don't need the best seed.
                $self->{id} = int(rand 65535) + 1;
        }
        return $self->{id};
>>>>>>> 1.19
a201 1
<<<<<<< Collector.pm
a379 5
=======
        # This method installs the collector on the source router.  It
        # assumes that the source has been successfully learned.
        my $self = shift;
        my ($source, $target, $operation, $id, $sess);
a380 20
        $source = $self->source();
        $target = $self->target();
        $id     = $self->id();

        if ($source->status() != HOST_UP_SNMP) {
                $self->error("Status for host "
                            . $source->name()
                            . " indicates it is not SNMP reachable");
                return;
        }

        # A start time of 0 (the current default) is invalid.  A positive start time
        # must be specified in order for the collector to run.
        if ($self->start_time() == DEFAULT_START_TIME) {
                $self->error("Start time has not been set");
                return;
        }
>>>>>>> 1.19

<<<<<<< Collector.pm
a382 118
=======
        # For now, we use the read-only community string.  We'll change over
        # to read-write when we do the actual configuration.
        $sess = new SNMP::Session(
                DestHost  => $source->addr(),
                Community => $source->read_community(),
                Version   => $source->snmp_version(),
        );

        # We need to determine if the given $id is already in use on the
        # source router.  We will loop ten times or until we find a free
        # row id.
>>>>>>> 1.19
        my $i;
        for ($i = 0 ; $i < 10 ; $i++) {
                my $val = $sess->get($rttMonCtrlAdminStatus . '.' . $id);

                #last if ( $sess->{ErrorNum} ); <----

                last if ($val eq 'NOSUCHINSTANCE');

                #bugfix: $sess->ErrorNum returns 0 for each query on non-extistant
                #row. thus we need to exit out of loop using something else like $val
                # knail1 12/16/2001
                $id = $self->id(1);    # Force a new id to be generated.
        }

        # This really shouldn't happen.
        if ($i == 10) {
                $self->error("Unable to find a free row id after ten tries");
                return;
        }

        # Now that we have a valid row id, we can do the actual collector setup.
        $sess = new SNMP::Session(
                DestHost  => $source->addr(),
                Community => $source->write_community(),
                Version   => $source->snmp_version(),
        );

        # We will use the createAndWait method.
        $sess->set(
                new SNMP::Varbind(
                        [
                                $rttMonCtrlAdminStatus,          $id,
                                $rowStatusEnum->{createAndWait}, 'INTEGER'
                        ]
                )
        );

        if ($sess->{ErrorNum}) {
                $self->error("Failed to set row status");
                return;
        }
        my $varlist = new SNMP::VarList(

                #below: fixing calls to pull $operation data from $self instead of attempting locally
                # old:  $operation->protocol
                # new: $self->{operation}->{protocol}
                #knail1 12.16.2001
                [
                        $rttMonCtrlAdminRttType,    $id,
                        $self->{operation}->{type}, 'INTEGER'
                ],
                [
                        $rttMonEchoAdminProtocol,       $id,
                        $self->{operation}->{protocol}, 'INTEGER'
                ],
                [
                        $rttMonEchoAdminSourcePort,        $id,
                        $self->{operation}->source_port(), 'INTEGER'
                ],
                [
                        $rttMonEchoAdminTargetPort,        $id,
                        $self->{operation}->target_port(), 'INTEGER'
                ],
                [
                        $rttMonEchoAdminControlEnable,         $id,
                        $self->{operation}->control_enabled(), 'INTEGER'
                ],
                [
                        $rttMonEchoAdminTOS, $id, $self->{operation}->tos(),
                        'INTEGER'
                ],
                [
                        $rttMonEchoAdminCache,             $id,
                        $self->{operation}->admin_cache(), 'INTEGER'
                ],
        );

        # Add objects that may be undef for certain operations.

        if ($target) {
                push @@{$varlist},
                    [
                        $rttMonEchoAdminTargetAddress, $id,
                        addrToOctStr($target->addr()), 'OCTSTR'
                    ];
        }

        if ($self->{operation}->name_server()) {
                push @@{$varlist},
                    [
                        $rttMonEchoAdminNameServer, $id,
                        addrToOctStr($self->{operation}->name_server()),
                        'OCTSTR'
                    ];
        }

        if ($self->{operation}->admin_operation()) {
                push @@{$varlist},
                    [
                        $rttMonEchoAdminOperation,             $id,
                        $self->{operation}->admin_operation(), 'INTEGER'
                    ];
        }

        if ($self->{operation}->admin_strings()) {
a405 10
        if ($self->{operation}->admin_url()) {
                push @@{$varlist},
<<<<<<< Collector.pm
                  [
                    $$var, $id,
                    $self->{operation}->admin_strings()->[$i], 'OCTETSTR'
                  ];
            }
        }
    }
a414 12
=======
                    [
                        $rttMonEchoAdminURL,             $id,
                        $self->{operation}->admin_url(), 'OCTSTR'
                    ];
        }
>>>>>>> 1.19

<<<<<<< Collector.pm
=======
        # Set the objects on the source router.
>>>>>>> 1.19
a426 1
<<<<<<< Collector.pm
a429 2
=======
        $sess->set($varlist);
a434 1
>>>>>>> 1.19
@


1.19
log
@Clean up all the source with a nice call to:

perltidy -i=8 -t -pt=2 -bt=2 -sbt=2 -ci=4 -noll -sfs -nasc -ce
@
text
@d2 1
a2 1
# $Id: Collector.pm,v 1.18 2001/12/17 05:46:47 knail1 Exp $
d16 61
d137 1
d188 10
d204 1
d276 180
d478 1
d480 4
d495 1
d626 18
d649 1
d651 2
d654 1
d667 5
d678 1
@


1.18
log
@fixed a couple of bugs: documented them within code
@
text
@d2 1
a2 1
# $Id: Collector.pm,v 1.17 2001/12/03 06:25:01 jmarcus Exp $
d16 60
a75 60
    # ARG 1: String name
    # ARG 2: SAA::Source source
    # ARG 3: SAA::Operation operation
    # ARG 4: (optional) SAA::Target target
    my ( $that, @@args ) = @@_;
    my $class = ref($that) || $that;

    if ( scalar(@@args) < 3 || scalar(@@args) > 4 ) {
        croak "SAA::Collector: Wrong number of arguments passed to constructor";
    }

    my $self = {
        name          => $args[0],
        id            => undef,
        source        => $args[1],
        operation     => $args[2],
        target        => undef,
        startTime     => DEFAULT_START_TIME,
        life          => DEFAULT_LIFE,
        writeNVRAM    => FALSE,
        historyFilter => $historyFilterEnum->{none},
        startTime     => DEFAULT_START_TIME,
        error         => undef,
    };

    my $rc = _needTarget( $self->{operation}->type() );
    if ( scalar(@@args) == 4 && $rc ) {
        $self->{target} = $args[3];
    }
    elsif ( scalar(@@args) < 4 && $rc ) {
        croak
          "SAA::Collector: The specified operation requires a target argument";
    }

    #bugfix for proto support
    #values stored in SAA::Operation's operation for protocol are
    #numerical while values stored in SAA::Source's list of supported
    #protocols are textual as per operationProtocolEnum
    #FIX:feeding SAA::Source's object textual info after converting numerical
    #info from SAA::Operations object.
    # 12/16/2001 knail1

    my %operationProtocolEnum_rev = reverse %$operationProtocolEnum;
    my $protocol_textual          =
      $operationProtocolEnum_rev{ $self->{operation}->{protocol} };

    if ( !$self->{source}->protocol_supported($protocol_textual) ) {
        croak
"SAA::Collector: The specified protocol is not supported by this source router";
    }

    #bugfix for type support: same problem as protocol entry, similar fix:
    # 12/16/2001 knail1
    my %operationTypeEnum_rev = reverse %$operationTypeEnum;
    my $type_textual = $operationTypeEnum_rev{ $self->{operation}->{type} };

    if ( !$self->{source}->type_supported($type_textual) ) {
        croak
"SAA::Collector: The specified RTT type is not supported by this source router";
    }
d77 2
a78 2
    bless( $self, $class );
    $self;
d83 16
a98 15
    if ( scalar(@@_) != 1 ) {
        croak "SAA::Collector::_needTarget: method requires one argument";
    }

    # This is a private static method to determine if a given operation type
    # needs a target.  HTTP, DNS, FTP and DHCP operations do not need targets.
    my $type = shift;

    if ( $type == $operationTypeEnum->{dns}
        || $type == $operationTypeEnum->{http}
        || $type == $operationTypeEnum->{dhcp}
        || $type == $operationTypeEnum->{ftp} )
    {
        return 0;
    }
d100 1
a100 1
    1;
d104 2
a105 2
    my $self = shift;
    return $self->{source};
d109 2
a110 2
    my $self = shift;
    return $self->{target};
d114 2
a115 2
    my $self = shift;
    return $self->{name};
d119 2
a120 2
    my $self = shift;
    my ($override);
d122 1
a122 1
    if (@@_) { $override = shift; }
d124 1
a124 1
    if ( !$self->{id} || $override ) {
d126 6
a131 6
        # Don't calculate id if it's already set or unless we're forced
        # to (by setting $override to 1).
        srand( time ^ $$ );    # We don't need the best seed.
        $self->{id} = int( rand 65535 ) + 1;
    }
    return $self->{id};
d135 9
a143 9
    my $self = shift;
    if (@@_) {
        my $val = shift;
        if ( $val != TRUE && $val != FALSE ) {
            return $self->{writeNVRAM};
        }
        $self->{writeNVRAM} = $val;
    }
    return $self->{writeNVRAM};
d147 18
a164 18
    my $self = shift;
    my $filter;
    if (@@_) {
        my $val = shift;
        foreach ( keys %{$historyFilterEnum} ) {

            if ( $val == $historyFilterEnum->{$_} ) {
                $filter = $val;
                last;
            }
        }

        if ( !$filter ) {
            return $self->{historyFilter};
        }
        $self->{historyFilter} = $filter;
    }
    return $self->{historyFilter};
d168 8
a175 8
    my $self = shift;
    if (@@_) {
        my $duration = shift;
        if ( $duration < MIN_LIFE || $duration > MAX_LIFE ) {
            return $self->{life};
        }
        else {
            $self->{life} = $duration;
d177 1
a177 2
    }
    return $self->{life};
d181 1
a181 1
    my $self = shift;
d183 10
a192 10
    # Since this objet represents TimeTicks, it can have pretty much any range.
    # We cast the value to an int which should make things safe.
    if (@@_) {
        my $time = shift;
        if ( $time < 0 ) {    # We can't time travel.
            return DEFAULT_START_TIME;
        }
        $self->{startTime} = int($time);
    }
    return $self->{startTime};
d196 3
a198 3
    my $self = shift;
    if (@@_) { $self->{error} = shift; }
    return $self->{error};
d203 22
a224 130
    # This method installs the collector on the source router.  It 
    # assumes that the source has been successfully learned.
    my $self = shift;
    my ( $source, $target, $operation, $id, $sess );

    $source = $self->source();
    $target = $self->target();
    $id     = $self->id();

    if ( $source->status() != HOST_UP_SNMP ) {
        $self->error( "Status for host "
            . $source->name()
            . " indicates it is not SNMP reachable" );
        return;
    }

    # A start time of 0 (the current default) is invalid.  A positive start time
    # must be specified in order for the collector to run.
    if ( $self->start_time() == DEFAULT_START_TIME ) {
        $self->error("Start time has not been set");
        return;
    }

    # For now, we use the read-only community string.  We'll change over
    # to read-write when we do the actual configuration.
    $sess = new SNMP::Session(
        DestHost  => $source->addr(),
        Community => $source->read_community(),
        Version   => $source->snmp_version(),
    );

    # We need to determine if the given $id is already in use on the 
    # source router.  We will loop ten times or until we find a free 
    # row id.
    my $i;
    for ( $i = 0 ; $i < 10 ; $i++ ) {
        my $val = $sess->get( $rttMonCtrlAdminStatus . '.' . $id );

        #last if ( $sess->{ErrorNum} ); <----

        last if ( $val eq 'NOSUCHINSTANCE' );

        #bugfix: $sess->ErrorNum returns 0 for each query on non-extistant
        #row. thus we need to exit out of loop using something else like $val
        # knail1 12/16/2001
        $id = $self->id(1);    # Force a new id to be generated.
    }

    # This really shouldn't happen.
    if ( $i == 10 ) {
        $self->error("Unable to find a free row id after ten tries");
        return;
    }

    # Now that we have a valid row id, we can do the actual collector setup.
    $sess = new SNMP::Session(
        DestHost  => $source->addr(),
        Community => $source->write_community(),
        Version   => $source->snmp_version(),
    );

    # We will use the createAndWait method.
    $sess->set(
        new SNMP::Varbind(
            [
                $rttMonCtrlAdminStatus,          $id,
                $rowStatusEnum->{createAndWait}, 'INTEGER'
            ]
          )
    );

    if ( $sess->{ErrorNum} ) {
        $self->error("Failed to set row status");
        return;
    }
    my $varlist = new SNMP::VarList(

        #below: fixing calls to pull $operation data from $self instead of attempting locally
        # old:  $operation->protocol
        # new: $self->{operation}->{protocol}
        #knail1 12.16.2001
        [ $rttMonCtrlAdminRttType, $id, $self->{operation}->{type}, 'INTEGER' ],
        [
            $rttMonEchoAdminProtocol,       $id,
            $self->{operation}->{protocol}, 'INTEGER'
        ],
        [
            $rttMonEchoAdminSourcePort,        $id,
            $self->{operation}->source_port(), 'INTEGER'
        ],
        [
            $rttMonEchoAdminTargetPort,        $id,
            $self->{operation}->target_port(), 'INTEGER'
        ],
        [
            $rttMonEchoAdminControlEnable,         $id,
            $self->{operation}->control_enabled(), 'INTEGER'
        ],
        [ $rttMonEchoAdminTOS, $id, $self->{operation}->tos(), 'INTEGER' ],
        [
            $rttMonEchoAdminCache,             $id,
            $self->{operation}->admin_cache(), 'INTEGER'
        ],
    );

    # Add objects that may be undef for certain operations.

    if ($target) {
        push @@{$varlist},
          [
            $rttMonEchoAdminTargetAddress,   $id,
            addrToOctStr( $target->addr() ), 'OCTSTR'
          ];
    }

    if ( $self->{operation}->name_server() ) {
        push @@{$varlist},
          [
            $rttMonEchoAdminNameServer,                        $id,
            addrToOctStr( $self->{operation}->name_server() ), 'OCTSTR'
          ];
    }

    if ( $self->{operation}->admin_operation() ) {
        push @@{$varlist},
          [
            $rttMonEchoAdminOperation,             $id,
            $self->{operation}->admin_operation(), 'INTEGER'
          ];
    }
d226 11
a236 1
    if ( $self->{operation}->admin_strings() ) {
d238 128
a365 6
        for ( $i = 0 ; $i < scalar( @@{ $self->{operation}->admin_strings() } ) ;
            $i++ )
        {
            if ( $self->{operation}->admin_strings()->[$i] ) {
                my $var = "rttMonEchoAdminString" . ( $i + 1 );
                no strict 'refs';    # We need to do this to allow $$var
d367 5
a371 15
                  [
                    $$var, $id,
                    $self->{operation}->admin_strings()->[$i], 'OCTSTR'
                  ];
            }
        }
    }

    if ( $self->{operation}->admin_url() ) {
        push @@{$varlist},
          [
            $rttMonEchoAdminURL,             $id,
            $self->{operation}->admin_url(), 'OCTSTR'
          ];
    }
d373 1
a373 1
    # Set the objects on the source router.
d376 9
a384 9
    # to fix the snmp set failure bug.
    #foreach (@@$varlist)	{
    #	my $tmp = $_;
    #	foreach (@@$tmp){
    #	chomp;
    #	print $_." ";
    #			}
    #	print "\n";
    #			}
d386 6
a391 1
    $sess->set($varlist);
d393 24
a416 20
    if ( $sess->{ErrorNum} ) {
        $self->error("Failed to set collector");
        return;
    }

    $varlist = new SNMP::VarList(
        [ $rttMonScheduleAdminRttLife, $id, $self->life(), 'INTEGER' ],
        [ $rttMonScheduleAdminRttStartTime, $id, $self->start_time(), 'TICKS' ],
        [ $rttMonHistoryAdminFilter, $id, $self->history_filter(),  'INTEGER' ],
        [ $rttMonCtrlAdminNvgen,     $id, $self->write_nvram(),     'INTEGER' ],
        [ $rttMonCtrlAdminStatus,    $id, $rowStatusEnum->{active}, 'INTEGER' ]
    );

    # Turn it on!
    $sess->set($varlist);

    if ( $sess->{ErrorNum} ) {
        $self->error("Failed to start collector");
        return;
    }
d418 1
a418 1
    1;
d422 9
a430 1
    my $self = shift;
d432 19
a450 27
    # Remove the collector by setting rttMonCtrlAdminStatus to destroy(6).
    if ( !$self->id() ) {
        $self->error("Collector id is not set");
        return;
    }

    my $source = $self->source();

    my $sess = new SNMP::Session(
        DestHost  => $source->addr(),
        Community => $source->write_community(),
        Version   => $source->snmp_version(),
    );

    $sess->set(
        new SNMP::Varbind(
            [
                $rttMonCtrlAdminStatus,    $self->id(),
                $rowStatusEnum->{destroy}, 'INTEGER'
            ]
          )
    );

    if ( $sess->{ErrorNum} ) {
        $self->error("Failed to uninstall collector");
        return;
    }
d452 1
a452 1
    1;
@


1.17
log
@Fix bug in exporter.
@
text
@d2 1
a2 1
# $Id: Collector.pm,v 1.16 2001/10/04 20:21:46 jmarcus Exp $
d24 1
a24 1
        croak "SAA::Collector: Insufficient arguments passed to constructor";
d50 13
a62 3
    if (
        !$self->{source}->protocol_supported( $self->{operation}->{protocol} ) )
    {
d67 6
a72 1
    if ( !$self->{source}->type_supported( $self->{operation}->{type} ) ) {
d240 8
a247 1
        last if ( $sess->{ErrorNum} );
d279 6
a284 2
        [ $rttMonCtrlAdminRttType,  $id, $operation->type(),     'INTEGER' ],
        [ $rttMonEchoAdminProtocol, $id, $operation->protocol(), 'INTEGER' ],
d286 2
a287 2
            $rttMonEchoAdminSourcePort, $id,
            $operation->source_port(),  'INTEGER'
d290 2
a291 2
            $rttMonEchoAdminTargetPort, $id,
            $operation->target_port(),  'INTEGER'
d294 11
a304 2
            $rttMonEchoAdminControlEnable, $id,
            $operation->control_enable(),  'INTEGER'
a305 2
        [ $rttMonEchoAdminTOS,   $id, $operation->tos(),         'INTEGER' ],
        [ $rttMonEchoAdminCache, $id, $operation->admin_cache(), 'INTEGER' ],
d318 1
a318 1
    if ( $operation->name_server() ) {
d321 2
a322 2
            $rttMonEchoAdminNameServer,                $id,
            addrToOctStr( $operation->name_server() ), 'OCTSTR'
d326 1
a326 1
    if ( $operation->admin_operation() ) {
d329 2
a330 2
            $rttMonEchoAdminOperation,     $id,
            $operation->admin_operation(), 'INTEGER'
d334 1
a334 1
    if ( $operation->admin_strings() ) {
d336 2
a337 1
        for ( $i = 0 ; $i < scalar( @@{ $operation->admin_strings() } ) ; $i++ )
d339 1
a339 1
            if ( $operation->admin_strings()->[$i] ) {
d343 4
a346 1
                  [ $$var, $id, $operation->admin_strings()->[$i], 'OCTSTR' ];
d351 1
a351 1
    if ( $operation->admin_url() ) {
d353 4
a356 1
          [ $rttMonEchoAdminURL, $id, $operation->admin_url(), 'OCTSTR' ];
d360 12
@


1.16
log
@Add $Id$ CVS tags.
@
text
@d2 1
a2 1
# $Id$
d33 5
a37 5
        startTime     => SAA::SAA_MIB::DEFAULT_START_TIME,
        life          => SAA::SAA_MIB::DEFAULT_LIFE,
        writeNVRAM    => SAA::SAA_MIB::FALSE,
        historyFilter => $SAA::SAA_MIB::historyFilterEnum->{none},
        startTime     => SAA::SAA_MIB::DEFAULT_START_TIME,
d76 4
a79 4
    if ( $type == $SAA::SAA_MIB::operationTypeEnum->{dns}
        || $type == $SAA::SAA_MIB::operationTypeEnum->{http}
        || $type == $SAA::SAA_MIB::operationTypeEnum->{dhcp}
        || $type == $SAA::SAA_MIB::operationTypeEnum->{ftp} )
d122 1
a122 1
        if ( $val != SAA::SAA_MIB::TRUE && $val != SAA::SAA_MIB::FALSE ) {
d135 1
a135 1
        foreach ( keys %{$SAA::SAA_MIB::historyFilterEnum} ) {
d137 1
a137 1
            if ( $val == $SAA::SAA_MIB::historyFilterEnum->{$_} ) {
d155 1
a155 3
        if ( $duration < SAA::SAA_MIB::MIN_LIFE
            || $duration > SAA::SAA_MIB::MAX_LIFE )
        {
d173 1
a173 1
            return SAA::SAA_MIB::DEFAULT_START_TIME;
d197 3
a199 2
    if ( $source->status() != SAA::Globals::HOST_UP_SNMP ) {
        $self->error( "Status for host " . $source->name()
d206 1
a206 1
    if ( $self->start_time() == SAA::SAA_MIB::DEFAULT_START_TIME ) {
d224 1
a224 2
        my $val =
          $sess->get( $SAA::SAA_MIB::rttMonCtrlAdminStatus . '.' . $id );
d246 2
a247 2
                $SAA::SAA_MIB::rttMonCtrlAdminStatus,          $id,
                $SAA::SAA_MIB::rowStatusEnum->{createAndWait}, 'INTEGER'
d249 1
a249 1
        )
d257 2
d260 2
a261 10
            $SAA::SAA_MIB::rttMonCtrlAdminRttType, $id,
            $operation->type(),                    'INTEGER'
        ],
        [
            $SAA::SAA_MIB::rttMonEchoAdminProtocol, $id,
            $operation->protocol(),                 'INTEGER'
        ],
        [
            $SAA::SAA_MIB::rttMonEchoAdminSourcePort, $id,
            $operation->source_port(),                'INTEGER'
d264 2
a265 2
            $SAA::SAA_MIB::rttMonEchoAdminTargetPort, $id,
            $operation->target_port(),                'INTEGER'
d268 2
a269 10
            $SAA::SAA_MIB::rttMonEchoAdminControlEnable, $id,
            $operation->control_enable(),                'INTEGER'
        ],
        [
            $SAA::SAA_MIB::rttMonEchoAdminTOS, $id,
            $operation->tos(),                 'INTEGER'
        ],
        [
            $SAA::SAA_MIB::rttMonEchoAdminCache, $id,
            $operation->admin_cache(),           'INTEGER'
d271 2
d280 3
a282 3
            $SAA::SAA_MIB::rttMonEchoAdminTargetAddress, $id,
            addrToOctStr( $target->addr() ),             'OCTSTR'
        ];
d288 1
a288 1
            $SAA::SAA_MIB::rttMonEchoAdminNameServer,  $id,
d290 1
a290 1
        ];
d296 3
a298 3
            $SAA::SAA_MIB::rttMonEchoAdminOperation, $id,
            $operation->admin_operation(),           'INTEGER'
        ];
d306 1
a306 1
                my $var = "SAA::SAA_MIB::rttMonEchoAdminString" . ( $i + 1 );
d316 1
a316 4
          [
            $SAA::SAA_MIB::rttMonEchoAdminURL, $id,
            $operation->admin_url(),           'OCTSTR'
        ];
d328 5
a332 20
        [
            $SAA::SAA_MIB::rttMonScheduleAdminRttLife, $id,
            $self->life(),                             'INTEGER'
        ],
        [
            $SAA::SAA_MIB::rttMonScheduleAdminRttStartTime, $id,
            $self->start_time(),                            'TICKS'
        ],
        [
            $SAA::SAA_MIB::rttMonHistoryAdminFilter, $id,
            $self->history_filter(),                 'INTEGER'
        ],
        [
            $SAA::SAA_MIB::rttMonCtrlAdminNvgen, $id,
            $self->write_nvram(),                'INTEGER'
        ],
        [
            $SAA::SAA_MIB::rttMonCtrlAdminStatus,   $id,
            $SAA::SAA_MIB::rowStatusEnum->{active}, 'INTEGER'
        ]
d366 2
a367 2
                $SAA::SAA_MIB::rttMonCtrlAdminStatus,    $self->id(),
                $SAA::SAA_MIB::rowStatusEnum->{destroy}, 'INTEGER'
d369 1
a369 1
        )
@


1.15
log
@Add support for the rttMonEchoAdminCache object.
@
text
@d1 3
@


1.14
log
@FTP operations also do not require a target.
@
text
@d75 2
a76 2
        || $type == $SAA::SAA_MIB::operationTypeEnum->{dhcp} 
		|| $type == $SAA::SAA_MIB::operationTypeEnum->{ftp} )
d280 4
d290 4
a293 2
          [ $SAA::SAA_MIB::rttMonEchoAdminTargetAddress, $id,
            addrToOctStr( $target->addr() ), 'OCTSTR' ];
d306 4
a309 2
          [ $SAA::SAA_MIB::rttMonEchoAdminOperation, $id,
            $operation->admin_operation(), 'INTEGER' ];
d327 4
a330 2
          [ $SAA::SAA_MIB::rttMonEchoAdminURL, $id, $operation->admin_url(),
            'OCTSTR' ];
@


1.13
log
@Coding, coding coding....
@
text
@d70 1
a70 1
    # needs a target.  HTTP, DNS, and DHCP operations do not need targets.
d75 2
a76 1
        || $type == $SAA::SAA_MIB::operationTypeEnum->{dhcp} )
@


1.12
log
@More Collector code.
@
text
@d34 1
d168 7
a174 1
    if (@@_) { $self->{startTime} = int(shift); }
d201 7
a263 4
            $SAA::SAA_MIB::rttMonEchoAdminSourceAddress, $id,
            addrToOctStr( $source->addr() ),             'OCTETSTR'
        ],
        [
d285 2
a286 4
          [
            $SAA::SAA_MIB::rttMonEchoAdminTargetAddress, $id,
            addrToOctStr( $target->addr() ),             'OCTSTR'
        ];
d297 1
a297 1
    if ( $operation->http_operation() ) {
d299 2
a300 4
          [
            $SAA::SAA_MIB::rttMonEchoAdminOperation, $id,
            $operation->http_operation(),            'INTEGER'
        ];
d303 1
a303 1
    if ( $operation->http_strings() ) {
d305 3
a307 2
        for ( $i = 0 ; $i < scalar( @@{ $operation->http_strings() } ) ; $i++ ) {
            if ( $operation->http_strings()->[$i] ) {
d311 1
a311 1
                  [ $$var, $id, $operation->http_strings()->[$i], 'OCTSTR' ];
d316 1
a316 1
    if ( $operation->http_url() ) {
d318 2
a319 4
          [
            $SAA::SAA_MIB::rttMonEchoAdminURL, $id,
            $operation->http_url(),            'OCTSTR'
        ];
d326 1
a326 1
        $self->error( "Failed to set collector, " . $self->{name} );
d329 67
@


1.11
log
@More Operation fields and code cleanup.
@
text
@d275 4
a278 2
          [ $SAA::SAA_MIB::rttMonEchoAdminTargetAddress, $id,
            addrToOctStr( $target->addr() ), 'OCTSTR' ];
d291 24
a314 2
          [ $SAA::SAA_MIB::rttMonEchoAdminOperation, $id,
            $operation->http_operation(), 'INTEGER' ];
@


1.10
log
@More Collector code.
@
text
@d272 1
d279 7
a285 3
	if ($operation->name_server()) {
		push @@{$varlist}, [ $SAA::SAA_MIB::rttMonEchoAdminNameServer, $id, addrToOctStr( $operation->name_server() ), 'OCTSTR'];
	}
d287 5
a291 3
	if ($operation->http_operation()) {
		push @@{$varlist}, [ $SAA::SAA_MIB::rttMonEchoAdminOperation, $id, $operation->http_operation(), 'INTEGER'];
	}
@


1.9
log
@Added a check to verify the specified protocol and type are supported by
the specified source router.
@
text
@d46 6
a51 3
	if (!$self->{source}->protocol_supported($self->{operation}->{protocol})) {
		croak "SAA::Collector: The specified protocol is not supported by this source router";
	}
d53 4
a56 3
	if (!$self->{source}->type_supported($self->{operation}->{type})) {
		croak "SAA::Collector: The specified type is not supported by this source router";
	}
d131 1
d137 1
d251 1
a251 1
            addrToOctStr( $source->addr() ),            'OCTETSTR'
a268 4
        [
            $SAA::SAA_MIB::rttMonEchoAdminNameServer,   $id,
            addrToOctStr( $operation->name_server() ), 'OCTETSTR'
        ],
d271 13
a283 4
# Add objects that may be undef for certain operations.
	if ($target) {
		push @@{$varlist}, [ $SAA::SAA_MIB::rttMonEchoAdminTargetAddress, $id,
		addrToOctStr( $target->addr() ), 'OCTSTR' ];
@


1.8
log
@More code changes and additions.  Moved some of the more prominent
private static methods into Globals, and made them public static.
@
text
@d46 8
@


1.7
log
@Increase random range by one.
@
text
@d33 1
a33 1
        historyFilter => $SAA::SAA_MIB::historFilterEnum->{none},
a162 14
sub _addrToOctStr {

    if ( scalar(@@_) != 1 ) {
        croak "SAA::Collector::_addrToOctStr: method requires one argument";
    }

    # Private static method to convert an IP address string into a 4-byte
    # octet string.  
    # XXX This should be smarter so that SNA address can also be supported.
    my $addr = shift;
    my ( $a, $b, $c, $cidr ) = split ( /\./, $addr );
    return ( sprintf "%.2x %.2x %.2x %.2x", $a, $b, $c, $cidr );
}

d237 1
a237 1
            _addrToOctStr( $source->addr() ),            'OCTETSTR'
a243 4
            $SAA::SAA_MIB::rttMonEchoAdminTargetAddress, $id,
            _addrToOctStr( $target->addr() ),            'OCTETSTR'
        ],
        [
d257 1
a257 1
            _addrToOctStr( $operation->name_server() ), 'OCTETSTR'
d260 6
@


1.6
log
@Massive OOP style changes.
@
text
@d96 1
a96 1
        $self->{id} = int( rand 65534 ) + 1;
@


1.5
log
@Added more Collector code, and cleaned up Operation some.
@
text
@a8 1
use SAA::Operation;
a10 22
# Default collector values
$SAA::Collector::DEFAULT_START_TIME = 0;
$SAA::Collector::DEFAULT_LIFE       = 3600;

# End defaults

# Collector maximums
$SAA::Collector::MAX_LIFE = 2147483647;

# End maximums

# Collector minimums
$SAA::Collector::MIN_LIFE = 0;

# End minimums

# Collector globals
$SAA::Collector::START_TIME_NOW = 1;
$SAA::Collector::LIVE_FOREVER   = $SAA::Collector::MAX_LIFE;

# End globals

d30 3
a32 3
        startTime     => $SAA::Collector::DEFAULT_START_TIME,
        life          => $SAA::Collector::DEFAULT_LIFE,
        writeNVRAM    => $SAA::SAA_MIB::FALSE,
d52 4
d60 3
a62 3
    if ( $type == $SAA::Operation::TYPE_DNS
        || $type == $SAA::Operation::TYPE_HTTP
        || $type == $SAA::Operations::TYPE_DHCP )
d105 1
a105 1
        if ( $val != $SAA::SAA_MIB::TRUE && $val != $SAA::SAA_MIB::FALSE ) {
d136 2
a137 2
        if ( $duration < $SAA::Collector::MIN_LIFE
            || $duration > $SAA::Collector::MAX_LIFE )
d150 4
a153 11
    if (@@_) {
        my $start = shift;
        if ( $start < $SAA::Collector::MIN_START_TIME
            || $start > $SAA::MAX_START_TIME )
        {
            return $self->{startTime};
        }
        else {
            $self->{startTime} = $start;
        }
    }
d165 4
d171 1
a171 1
	# XXX This should be smarter so that SNA address can also be supported.
d188 1
a188 1
    if ( $source->status() != $SAA::Globals::HOST_UP_SNMP ) {
@


1.4
log
@Add a few more accessor methods and start work on the install method.  There
is still much to be done.
@
text
@d48 10
a57 8
        name      => $args[0],
        id        => undef,
        source    => $args[1],
        operation => $args[2],
        target    => undef,
        startTime => $SAA::Collector::DEFAULT_START_TIME,
        life      => $SAA::Collector::DEFAULT_LIFE,
        error     => undef,
d120 31
d189 10
d252 2
a253 2
                $SAA::SAA_MIB::rttMonCtrlAdminStatus, $id,
                $SAA::SAA_MIB::createAndWait, 'INTEGER'
d260 46
@


1.3
log
@Coded some more methods.
@
text
@d7 1
d58 7
a64 3
    if ( $args[3] ) {
        my $rc = _needTarget( $self->{operation}->{type} );
        $self->{target} = $args[3] if $rc;
d87 31
d119 13
a131 11
	my $self = shift;
	if (@@_) { 
		my $duration = shift;
		if ($duration < $SAA::Collector::MIN_LIFE || $duration > $SAA::Collector::MAX_LIFE) {
			return $self->{life};
		}
		else {
			$self->{life} = $duration;
		}
	}
	return $self->{life};
d135 84
a218 11
	my $self = shift;
	if (@@_) {
		my $start = shift;
		if ($start < $SAA::Collector::MIN_START_TIME || $start > $SAA::MAX_START_TIME) {
			return $self->{startTime};
		}
		else {
			$self->{startTime} = $start;
		}
	}
	return $self->{startTime};
@


1.2
log
@Code _needTarget().  This requires SAA::Operation to be use'd.
@
text
@d70 1
a70 1
    my ($type) = $_[0];
d80 28
@


1.1
log
@Initial import into CVS.
@
text
@d8 1
d65 18
@

