head	1.16;
access;
symbols
	RELEASE_1_1_1:1.16
	RELEASE_1_1:1.14
	RELEASE_1_0_1:1.10
	RELEASE_1_0:1.9
	DEVEL_1_0:1.1.1.1
	MarcusCom:1.1.1;
locks; strict;
comment	@# @;


1.16
date	2004.07.06.04.24.37;	author jmarcus;	state Exp;
branches;
next	1.15;

1.15
date	2004.07.02.04.28.43;	author jmarcus;	state Exp;
branches;
next	1.14;

1.14
date	2004.07.01.04.01.04;	author jmarcus;	state Exp;
branches;
next	1.13;

1.13
date	2004.07.01.03.58.56;	author jmarcus;	state Exp;
branches;
next	1.12;

1.12
date	2004.07.01.03.57.58;	author jmarcus;	state Exp;
branches;
next	1.11;

1.11
date	2004.06.29.22.21.26;	author jmarcus;	state Exp;
branches;
next	1.10;

1.10
date	2001.11.17.02.58.03;	author jmarcus;	state Exp;
branches;
next	1.9;

1.9
date	2001.11.06.01.05.03;	author jmarcus;	state Exp;
branches;
next	1.8;

1.8
date	2001.11.05.05.44.25;	author jmarcus;	state Exp;
branches;
next	1.7;

1.7
date	2001.10.21.02.39.09;	author jmarcus;	state Exp;
branches;
next	1.6;

1.6
date	2001.06.17.07.20.03;	author jmarcus;	state Exp;
branches;
next	1.5;

1.5
date	2001.06.15.16.46.19;	author jmarcus;	state Exp;
branches;
next	1.4;

1.4
date	2001.06.14.20.25.41;	author jmarcus;	state Exp;
branches;
next	1.3;

1.3
date	2001.06.14.18.34.00;	author jmarcus;	state Exp;
branches;
next	1.2;

1.2
date	2001.06.14.16.40.34;	author jmarcus;	state Exp;
branches;
next	1.1;

1.1
date	2001.06.13.18.44.05;	author jmarcus;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.06.13.18.44.05;	author jmarcus;	state Exp;
branches;
next	;


desc
@@


1.16
log
@Fix a bug that popped up when switching to Jakarta-ORO.  The buffer was no
longer being evaluated as multiple-line input.  Therefore, '^' anchors were
not matching.  This restores the older MISAL behavior.  Now '^' and '$'
anchors should work as expected.
@
text
@package com.marcuscom.MISAL;
/*-
 * Copyright (c) 2001-2004 Joe Clarke <marcus@@marcuscom.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $Id: MISALCiscoIOS.java,v 1.15 2004/07/02 04:28:43 jmarcus Exp $
 */
import java.io.*;
import java.net.*;
import org.apache.oro.text.regex.*;

/** <p>MISALCiscoIOS is an extension of MISAL designed to interact with Cisco
 * IOS devices.  It allows one to telnet into an IOS device, become enabled, and
 * execute IOS commands.</p>
 * @@author Joe Clarke &lt;marcus@@marcuscom.com&gt;
 * @@version $Id: MISALCiscoIOS.java,v 1.15 2004/07/02 04:28:43 jmarcus Exp $
 * @@since MISAL 1.0
 */
public class MISALCiscoIOS extends MISAL {
    /** The state matching the normal Cisco IOS prompt (usually a prompt ending in
     * '&gt;').
     */
    public static final int DISABLE_MODE = 1;
    /** The state matching the normal Cisco IOS enable prompt (usually a prompt ending in '#').
     */
    public static final int ENABLE_MODE = 2;
    /** The state matching IOS config mode (usually a prompt ending in "(config)#").
     */
    public static final int CONFIG_MODE = 3;
    /** The state matching the IOS interface config mode (usually a prompt ending in "(config-if)#").
     */
    public static final int CONFIG_MODE_IF = 4;
    /** The state matching a config mode other than normal config and interface config.
     */
    public static final int CONFIG_MODE_OTHER = 5;
    /** The state matching a AAA username prompt (usually "Username:").
     */
    public static final int USER_PROMPT = 6;
    /** The state matching a password prompt (usually "Password:").
     */
    public static final int PASSWORD_PROMPT = 7;

    /** The state matched when no authentication level is known (e.g. before one even begins to log into an IOS device).
     */
    protected static final int AUTH_UNKNOWN = 0;
    /** The state matched when needing to authenticate using a VTY password.
     */
    protected static final int AUTH_VTY = 1;
    /** The state matched when needing to authenticate with a AAA (or local) username.
     */
    protected static final int AUTH_USER = 2;
    /** The state matched when needing to enter an enable password when no enable username is required.
     */
    protected static final int AUTH_VTY_ENABLE = 3;
    /** The state matched when needing to enter an enable username.
     */
    protected static final int AUTH_USER_ENABLE = 4;
    /** The state matched when needing to use an enable TACACS username to login (i.e. you login and immediately become enabled).
     */
    protected static final int AUTH_ENABLE_TACACS = 5;

    private String _vtyPw = null;
    private String _enablePw = null;
    private String _user = null;
    private String _userPw = null;
    private String _errorMessage = null;

    /** Creates a new MISALCiscoIOS socket.
     * @@since MISAL1.0
     * @@param socket the <I>open</I> java.net.Socket to be abstracted
     * @@throws SocketException if Socket is not initialized and connected
     * @@throws IOException if there is a problem reading or writing Socket
     */
    public MISALCiscoIOS(Socket socket) throws SocketException, IOException {
        super(socket);

        /* Add Cisco-specific states */
        try {
            /* Standard disable prompt */
            addState(this.DISABLE_MODE, ">$");
            /* Standard enable prompt */
            addState(this.ENABLE_MODE, "[^\\)]#$");
            /* Vanilla config prompt */
            addState(this.CONFIG_MODE, "\\(config\\)#$");
            /* Config interface prompt */
            addState(this.CONFIG_MODE_IF, "\\(config-if\\)#$");
            /* Some other config prompt */
            addState(this.CONFIG_MODE_OTHER, "\\(config-[^i][^f]\\)#$");
            addState(this.USER_PROMPT, "^Username:\\s.*$");
            addState(this.PASSWORD_PROMPT, "^Password:\\s.*$");
        }
        /* This code should not generate an exception.  These
           patterns are tested. */
        catch (MalformedMISALStateException mmse) {}
    }

    /** Set the enable password.  By default, this is null.
     * @@param enablePw the enable password to use
     * @@see #setVtyPassword(String)
     * @@see #setUserPassword(String)
     */
    public void setEnablePassword(String enablePw) {
        this._enablePw = enablePw;
    }

    /** Set the AAA or local username (if needed).  By default, this is null.
     * @@param username the username to use for AAA or local authentication
     * @@see #setUserPassword(String)
     */
    public void setUsername(String username) {
        this._user = username;
    }

    /** Set the VTY password.  By default, this is null.
     * @@param vtyPw the VTY password to use for basic authentication
     */
    public void setVtyPassword(String vtyPw) {
        this._vtyPw = vtyPw;
    }

    /** Set the user password for AAA or local authentication.  By default, this is null.
     * @@param userPw the user password to use for AAA or local authentication
     * @@see #setUsername(String)
     */
    public void setUserPassword(String userPw) {
        this._userPw = userPw;
    }

    /** Set the username prompt for AAA or local authentication.  By default, this is "Username:".
     * @@param prompt the value of the username prompt
     * @@throws MalformedMISALStateException if <CODE>prompt</CODE> is not a valid MISAL state
     * @@see #setPasswordPrompt(String)
     */
    public void setUserPrompt(String prompt) throws MalformedMISALStateException {
        addState(this.USER_PROMPT, prompt);
    }

    /** Set the password prompt for AAA or local authentication.  By default, this is "Password:".
     * @@param prompt the value of the password prompt
     * @@throws MalformedMISALStateException if <CODE>prompt</CODE> is not a valid MISAL state
     * @@see #setUserPrompt(String)
     */
    public void setPasswordPrompt(String prompt) throws MalformedMISALStateException {
        addState(this.PASSWORD_PROMPT, prompt);
    }

    /** Retrieve the last error message from the MISAL socket.  If no error message was encountered, this is null.
     * @@return last error message as a string
     * @@see #errorOccurred()
     */
    public String getLastErrorMessage() {
        return this._errorMessage;
    }

    private void setLastErrorMessage(String message) {
        this._errorMessage = message;
    }

    private int getAuthScheme(int state) throws InsufficientCredentialsException {
        int auth = this.AUTH_UNKNOWN;
        switch(state) {
        case DISABLE_MODE:
            if (this._vtyPw == null && (this._user == null || this._userPw == null)) {
                throw new InsufficientCredentialsException("Not enough credentials specified to log into device.");
            }
            else if (this._vtyPw != null) {
                auth = this.AUTH_VTY;
            }
            else {
                auth = this.AUTH_USER;
            }
            break;
        case ENABLE_MODE:
            if (this._enablePw != null && this._user != null && this._userPw != null) {
                auth = this.AUTH_USER_ENABLE;
            }
            else if (this._enablePw != null && this._vtyPw != null) {
                auth = this.AUTH_VTY_ENABLE;
            }
            else if (this._enablePw == null && this._user != null && this._userPw != null) {
                auth = this.AUTH_ENABLE_TACACS;
            }
            else {
                throw new InsufficientCredentialsException("Not enough credentials specified to gain enable privileges on device.");
            }
            break;
        }
        return auth;
    }

    /** Perform the login dialog with connected IOS device.  The expected result is either the disabled prompt or the enable prompt.
     * @@throws InsufficientCredentialsException if the authentication information cannot be used to make a successful login
     * @@throws IllegalMISALStateException if a valid logged in state is not reached
     * @@throws IOException if an error occurs reading or writing the MISAL socket
     * @@see #doEnable()
     * @@see #doDisable()
     * @@see #doConfig()
     */
    public void login() throws InsufficientCredentialsException, IllegalMISALStateException, IOException {
        switch (this.getAuthScheme(this.DISABLE_MODE)) {
        case AUTH_VTY:
            /* Expect a Password: prompt */
            send(this.PASSWORD_PROMPT, this._vtyPw + "\r", "[#>]$");
            /* If we don't get what we expect, throw
               the IllegalMISALStateException. */
            break;
        case AUTH_USER:
            try {
                /* Expect either ENABLE or DISABLE MODE
                   as we could be using enable TACACS */
                send(this.USER_PROMPT, this._user + "\r", this.PASSWORD_PROMPT);
                send(this.PASSWORD_PROMPT, this._userPw + "\r", "[#>]$");
            }
            catch (IllegalMISALStateException imse) {
                /* Fallback onto regular VTY logins. */
                send(this.PASSWORD_PROMPT, this._vtyPw + "\r", "[#>]$");
            }
            break;
        }

    }

    /** Become enabled on the connected IOS device.
     * @@throws IllegalMISALStateException if enable mode cannot be reached
     * @@throws IOException if an error occurs reading or writing the MISAL socket
     * @@see #doDisable()
     * @@see #doConfig()
     */
    public void doEnable() throws IllegalMISALStateException, IOException {
        switch (getState()) {
        case ENABLE_MODE:
            break;
        case DISABLE_MODE:
            send("enable\r", this.PASSWORD_PROMPT);
            send(this._enablePw + "\r", this.ENABLE_MODE);
            break;
        case CONFIG_MODE:
        case CONFIG_MODE_IF:
        case CONFIG_MODE_OTHER:
            send("end\r", this.ENABLE_MODE);
            break;
        default:
            throw new IllegalMISALStateException("Unable to get to enable mode");

        }
    }

    /** Become disabled on the connected IOS device.
     * @@throws IllegalMISALStateException if the disabled prompt cannot be reached
     * @@throws IOException if an error occurs reading or writing the MISAL socket
     * @@see #doEnable()
     */
    public void doDisable() throws IllegalMISALStateException, IOException {
        switch (getState()) {
        case DISABLE_MODE:
            break;
        case ENABLE_MODE:
            send("disable\r", this.DISABLE_MODE);
            break;
        case CONFIG_MODE:
        case CONFIG_MODE_IF:
        case CONFIG_MODE_OTHER:
            send("end\r", this.ENABLE_MODE);
            this.doDisable();
            break;
        default:
            throw new IllegalMISALStateException("Unable to get to disable mode");
        }
    }

    /** Enter config mode on the connected IOS device.
     * @@throws IllegalMISALStateException if config mode cannot be reached
     * @@throws IOException if an error occurs reading or writing the MISAL socket
     * @@see #doEnable()
     * @@see #doDisable()
     */
    public void doConfig() throws IllegalMISALStateException, IOException {
        switch (getState()) {
        case DISABLE_MODE:
            this.doEnable();
            this.doConfig();
            break;
        case ENABLE_MODE:
            send("config term\r", this.CONFIG_MODE);
            break;
        case CONFIG_MODE:
            break;
        case CONFIG_MODE_IF:
        case CONFIG_MODE_OTHER:
            this.doEnable();
            this.doConfig();
            break;
        default:
            throw new IllegalMISALStateException("Unable to get to config mode.");
        }
    }

    /** Check to see if an IOS parser error occurred.
     * @@return true if an IOS parser error occurred, false otherwise
     * @@see #getLastErrorMessage()
     */
    public boolean errorOccurred() {
        Perl5Matcher matcher = new Perl5Matcher();
        Perl5Compiler compiler = new Perl5Compiler();
        Pattern pattern = null;
        try {
	    matcher.setMultiline(true);
            pattern = compiler.compile("^% (.*)$");
        }
        catch (MalformedPatternException mfpe) {}
        if (matcher.contains(getLastBuffer(), pattern)) {
            this.setLastErrorMessage(matcher.getMatch().group(1));
            return true;
        }
        return false;
    }

    /** Send data on the MISAL socket.  This overrides <CODE>send</CODE> from <CODE>MISAL</CODE>.
     * @@param state integer representing the MISAL state to expect before sending data
     * @@param data string representing the data to send
     * @@param expect string representing the prompt to expect after sending the data (set to <CODE>null</CODE> to indicate a MISAL state integer will be provided)
     * @@param expectState integer representing the state to expect after sending the data (set to 0 to indicate a string prompt will be provided)
     * @@param wait number of seconds to wait for expected state
     * @@throws IllegalMISALStateException if the given states could not be reached
     * @@throws IOException if an error occurs reading or writing the MISAL socket
     * @@see MISAL#send(int,String,String,int,int)
     */
    protected void send(int state, String data, String expect, int expectState, int wait) throws IllegalMISALStateException, IOException {
        boolean result = false;
        int currState = MISAL_STATE_UNKNOWN;
        byte[] b = null;
        if (wait == 0) wait = DEFAULT_RETRIES;
        if (state > 0) {
            for (int i = 1; i <= wait; i++) {
                currState = getState();
                debug("i = " + i + " and currState = " + currState);
                if (currState == state) break;
                try {
                    /* Sleep only a short time between state
                      	checks .*/
                    Thread.sleep(MISAL_SHORT_THREAD_SLEEP_INTERVAL);
                }
                catch (InterruptedException ie) {}
            }
            if (currState != state) {
                switch (state) {
                case ENABLE_MODE:
                    this.doEnable();
                    break;
                case DISABLE_MODE:
                    this.doDisable();
                    break;
                case CONFIG_MODE:
                    this.doConfig();
                    break;
                default:
                    throw new IllegalMISALStateException("Needed state " + state + ", but found state " + currState);
                }
            }
            /* This check is really redundant. */
            if (getState() != state) {
                throw new IllegalMISALStateException("Unable to set the desired state.");
            }
        }
        b = new byte[data.length()];
        b = data.getBytes();
        debug("Sending data " + data);
        getOutputStream().write(b, 0, b.length);
        getOutputStream().flush();
        /* When sending a command, set the state to unknown.  It might
           be better to think of this as pending until we can check
           the new state. */
        setState(MISAL_STATE_UNKNOWN);
        if (expect != null) {
            debug("Expecting \"" + expect + "\"");
            result = expect(expect, wait);
        }
        else {
            debug("Expecting state: " + expectState);
            result = expect(expectState, wait);
        }
        if (!result) {
            throw new IllegalMISALStateException("Unable to reach expected state.");
        }
    }

    /** Start the MISAL state watcher thread.  This method should never be called directly.  It is run automatically once a new <CODE>MISALCiscoIOS</CODE> class is instantiated.
     */
    public void run() {
        super.run();
    }

}
@


1.15
log
@Check for enable and disable prompts when logging in for all cases.
@
text
@d27 1
a27 1
 * $Id: MISALCiscoIOS.java,v 1.14 2004/07/01 04:01:04 jmarcus Exp $
d37 1
a37 1
 * @@version $Id: MISALCiscoIOS.java,v 1.14 2004/07/01 04:01:04 jmarcus Exp $
d110 2
a111 2
            addState(this.USER_PROMPT, "Username:\\s.*$");
            addState(this.PASSWORD_PROMPT, "Password:\\s.*$");
d328 1
@


1.14
log
@Add 2004 to the copyrights.
@
text
@d27 1
a27 1
 * $Id: MISALCiscoIOS.java,v 1.13 2004/07/01 03:58:56 jmarcus Exp $
d37 1
a37 1
 * @@version $Id: MISALCiscoIOS.java,v 1.13 2004/07/01 03:58:56 jmarcus Exp $
d224 1
a224 1
            send(this.PASSWORD_PROMPT, this._vtyPw + "\r", this.DISABLE_MODE);
d233 1
a233 1
                send(this.PASSWORD_PROMPT, this._userPw + "\r", "[#>] ?$");
d237 1
a237 1
                send(this.PASSWORD_PROMPT, this._vtyPw + "\r", this.DISABLE_MODE);
@


1.13
log
@Cleanup trainling whitespace, and reformat using astyle -j.
@
text
@d3 1
a3 1
 * Copyright (c) 2001 Joe Clarke <marcus@@marcuscom.com>
d27 1
a27 1
 * $Id: MISALCiscoIOS.java,v 1.12 2004/07/01 03:57:58 jmarcus Exp $
d37 1
a37 1
 * @@version $Id: MISALCiscoIOS.java,v 1.12 2004/07/01 03:57:58 jmarcus Exp $
@


1.12
log
@Replace the old PerlTools imports with the new Jakarta ORO imports.
@
text
@d27 1
a27 1
 * $Id: MISALCiscoIOS.java,v 1.11 2004/06/29 22:21:26 jmarcus Exp $
d37 1
a37 1
 * @@version $Id: MISALCiscoIOS.java,v 1.11 2004/06/29 22:21:26 jmarcus Exp $
d43 69
a111 368
     */    
	public static final int DISABLE_MODE = 1;
        /** The state matching the normal Cisco IOS enable prompt (usually a prompt ending in '#').
         */        
	public static final int ENABLE_MODE = 2;
        /** The state matching IOS config mode (usually a prompt ending in "(config)#").
         */        
	public static final int CONFIG_MODE = 3;
        /** The state matching the IOS interface config mode (usually a prompt ending in "(config-if)#").
         */        
	public static final int CONFIG_MODE_IF = 4;
        /** The state matching a config mode other than normal config and interface config.
         */        
	public static final int CONFIG_MODE_OTHER = 5;
        /** The state matching a AAA username prompt (usually "Username:").
         */        
	public static final int USER_PROMPT = 6;
        /** The state matching a password prompt (usually "Password:").
         */        
	public static final int PASSWORD_PROMPT = 7;

        /** The state matched when no authentication level is known (e.g. before one even begins to log into an IOS device).
         */        
	protected static final int AUTH_UNKNOWN = 0;
        /** The state matched when needing to authenticate using a VTY password.
         */        
	protected static final int AUTH_VTY = 1;
        /** The state matched when needing to authenticate with a AAA (or local) username.
         */        
	protected static final int AUTH_USER = 2;
        /** The state matched when needing to enter an enable password when no enable username is required.
         */        
	protected static final int AUTH_VTY_ENABLE = 3;
        /** The state matched when needing to enter an enable username.
         */        
	protected static final int AUTH_USER_ENABLE = 4;
        /** The state matched when needing to use an enable TACACS username to login (i.e. you login and immediately become enabled).
         */        
	protected static final int AUTH_ENABLE_TACACS = 5;

	private String _vtyPw = null;
	private String _enablePw = null;
	private String _user = null;
	private String _userPw = null;
	private String _errorMessage = null;

        /** Creates a new MISALCiscoIOS socket.
         * @@since MISAL1.0
         * @@param socket the <I>open</I> java.net.Socket to be abstracted
         * @@throws SocketException if Socket is not initialized and connected
         * @@throws IOException if there is a problem reading or writing Socket
         */        
	public MISALCiscoIOS(Socket socket) throws SocketException, IOException {
		super(socket);

		/* Add Cisco-specific states */
		try {
			/* Standard disable prompt */
			addState(this.DISABLE_MODE, ">$"); 
			/* Standard enable prompt */
			addState(this.ENABLE_MODE, "[^\\)]#$"); 
			/* Vanilla config prompt */
			addState(this.CONFIG_MODE, "\\(config\\)#$");
			/* Config interface prompt */
			addState(this.CONFIG_MODE_IF, "\\(config-if\\)#$");
			/* Some other config prompt */
			addState(this.CONFIG_MODE_OTHER, "\\(config-[^i][^f]\\)#$");
			addState(this.USER_PROMPT, "Username:\\s.*$");
			addState(this.PASSWORD_PROMPT, "Password:\\s.*$");
		}
		/* This code should not generate an exception.  These
		   patterns are tested. */
		catch (MalformedMISALStateException mmse) {}
	}

        /** Set the enable password.  By default, this is null.
         * @@param enablePw the enable password to use
         * @@see #setVtyPassword(String)
         * @@see #setUserPassword(String)
         */        
	public void setEnablePassword(String enablePw) {
		this._enablePw = enablePw;
	}

        /** Set the AAA or local username (if needed).  By default, this is null.
         * @@param username the username to use for AAA or local authentication
         * @@see #setUserPassword(String)
         */        
	public void setUsername(String username) {
		this._user = username;
	}

        /** Set the VTY password.  By default, this is null.
         * @@param vtyPw the VTY password to use for basic authentication
         */        
	public void setVtyPassword(String vtyPw) {
		this._vtyPw = vtyPw;
	}

        /** Set the user password for AAA or local authentication.  By default, this is null.
         * @@param userPw the user password to use for AAA or local authentication
         * @@see #setUsername(String)
         */        
	public void setUserPassword(String userPw) {
		this._userPw = userPw;
	}

        /** Set the username prompt for AAA or local authentication.  By default, this is "Username:".
         * @@param prompt the value of the username prompt
         * @@throws MalformedMISALStateException if <CODE>prompt</CODE> is not a valid MISAL state
         * @@see #setPasswordPrompt(String)
         */        
	public void setUserPrompt(String prompt) throws MalformedMISALStateException {
		addState(this.USER_PROMPT, prompt);
	}

        /** Set the password prompt for AAA or local authentication.  By default, this is "Password:".
         * @@param prompt the value of the password prompt
         * @@throws MalformedMISALStateException if <CODE>prompt</CODE> is not a valid MISAL state
         * @@see #setUserPrompt(String)
         */        
	public void setPasswordPrompt(String prompt) throws MalformedMISALStateException {
		addState(this.PASSWORD_PROMPT, prompt);
	}

        /** Retrieve the last error message from the MISAL socket.  If no error message was encountered, this is null.
         * @@return last error message as a string
         * @@see #errorOccurred()
         */        
	public String getLastErrorMessage() {
		return this._errorMessage;
	}

	private void setLastErrorMessage(String message) {
		this._errorMessage = message;
	}

	private int getAuthScheme(int state) throws InsufficientCredentialsException {
		int auth = this.AUTH_UNKNOWN;
		switch(state) {
			case DISABLE_MODE:
				if (this._vtyPw == null && (this._user == null || this._userPw == null)) {
					throw new InsufficientCredentialsException("Not enough credentials specified to log into device.");
				}
				else if (this._vtyPw != null) {
					auth = this.AUTH_VTY;
				}
				else {
					auth = this.AUTH_USER;
				}
				break;
			case ENABLE_MODE:
				if (this._enablePw != null && this._user != null && this._userPw != null) {
					auth = this.AUTH_USER_ENABLE;
				}
				else if (this._enablePw != null && this._vtyPw != null) {
					auth = this.AUTH_VTY_ENABLE;
				}
				else if (this._enablePw == null && this._user != null && this._userPw != null) {
					auth = this.AUTH_ENABLE_TACACS;
				}
				else {
					throw new InsufficientCredentialsException("Not enough credentials specified to gain enable privileges on device.");
				}
				break;
		}
		return auth;
	}

        /** Perform the login dialog with connected IOS device.  The expected result is either the disabled prompt or the enable prompt.
         * @@throws InsufficientCredentialsException if the authentication information cannot be used to make a successful login
         * @@throws IllegalMISALStateException if a valid logged in state is not reached
         * @@throws IOException if an error occurs reading or writing the MISAL socket
         * @@see #doEnable()
         * @@see #doDisable()
         * @@see #doConfig()
         */        
	public void login() throws InsufficientCredentialsException, IllegalMISALStateException, IOException {
		switch (this.getAuthScheme(this.DISABLE_MODE)) {
			case AUTH_VTY:
				/* Expect a Password: prompt */
				send(this.PASSWORD_PROMPT, this._vtyPw + "\r", this.DISABLE_MODE);
				/* If we don't get what we expect, throw
				   the IllegalMISALStateException. */
				break;
			case AUTH_USER:
				try {
					/* Expect either ENABLE or DISABLE MODE
					   as we could be using enable TACACS */
					send(this.USER_PROMPT, this._user + "\r", this.PASSWORD_PROMPT);
					send(this.PASSWORD_PROMPT, this._userPw + "\r", "[#>] ?$");
				}
				catch (IllegalMISALStateException imse) {
					/* Fallback onto regular VTY logins. */
					send(this.PASSWORD_PROMPT, this._vtyPw + "\r", this.DISABLE_MODE);
				}
				break;
		}

	}

        /** Become enabled on the connected IOS device.
         * @@throws IllegalMISALStateException if enable mode cannot be reached
         * @@throws IOException if an error occurs reading or writing the MISAL socket
         * @@see #doDisable()
         * @@see #doConfig()
         */        
	public void doEnable() throws IllegalMISALStateException, IOException {
		switch (getState()) {
			case ENABLE_MODE:
				break;
			case DISABLE_MODE:
				send("enable\r", this.PASSWORD_PROMPT);
				send(this._enablePw + "\r", this.ENABLE_MODE);
				break;
			case CONFIG_MODE:
			case CONFIG_MODE_IF:
			case CONFIG_MODE_OTHER:
				send("end\r", this.ENABLE_MODE);
				break;
			default:
				throw new IllegalMISALStateException("Unable to get to enable mode");
				
		}
	}

        /** Become disabled on the connected IOS device.
         * @@throws IllegalMISALStateException if the disabled prompt cannot be reached
         * @@throws IOException if an error occurs reading or writing the MISAL socket
         * @@see #doEnable()
         */        
	public void doDisable() throws IllegalMISALStateException, IOException {
		switch (getState()) {
			case DISABLE_MODE:
				break;
			case ENABLE_MODE:
				send("disable\r", this.DISABLE_MODE);
				break;
			case CONFIG_MODE:
			case CONFIG_MODE_IF:
			case CONFIG_MODE_OTHER:
				send("end\r", this.ENABLE_MODE);
				this.doDisable();
				break;
			default:
				throw new IllegalMISALStateException("Unable to get to disable mode");
		}
	}

        /** Enter config mode on the connected IOS device.
         * @@throws IllegalMISALStateException if config mode cannot be reached
         * @@throws IOException if an error occurs reading or writing the MISAL socket
         * @@see #doEnable()
         * @@see #doDisable()
         */        
	public void doConfig() throws IllegalMISALStateException, IOException {
		switch (getState()) {
			case DISABLE_MODE:
				this.doEnable();
				this.doConfig();
				break;
			case ENABLE_MODE:
				send("config term\r", this.CONFIG_MODE);
				break;
			case CONFIG_MODE:
				break;
			case CONFIG_MODE_IF:
			case CONFIG_MODE_OTHER:
				this.doEnable();
				this.doConfig();
				break;
			default:
				throw new IllegalMISALStateException("Unable to get to config mode.");
		}
	}

        /** Check to see if an IOS parser error occurred.
         * @@return true if an IOS parser error occurred, false otherwise
         * @@see #getLastErrorMessage()
         */        
	public boolean errorOccurred() {
		Perl5Matcher matcher = new Perl5Matcher();
		Perl5Compiler compiler = new Perl5Compiler();
		Pattern pattern = null;
		try {
			pattern = compiler.compile("^% (.*)$");
		}
		catch (MalformedPatternException mfpe) {}
		if (matcher.contains(getLastBuffer(), pattern)) {
			this.setLastErrorMessage(matcher.getMatch().group(1));
			return true;
		}
		return false;
	}
		
        /** Send data on the MISAL socket.  This overrides <CODE>send</CODE> from <CODE>MISAL</CODE>.
         * @@param state integer representing the MISAL state to expect before sending data
         * @@param data string representing the data to send
         * @@param expect string representing the prompt to expect after sending the data (set to <CODE>null</CODE> to indicate a MISAL state integer will be provided)
         * @@param expectState integer representing the state to expect after sending the data (set to 0 to indicate a string prompt will be provided)
         * @@param wait number of seconds to wait for expected state
         * @@throws IllegalMISALStateException if the given states could not be reached
         * @@throws IOException if an error occurs reading or writing the MISAL socket
         * @@see MISAL#send(int,String,String,int,int)
         */        
	protected void send(int state, String data, String expect, int expectState, int wait) throws IllegalMISALStateException, IOException {
		boolean result = false;
		int currState = MISAL_STATE_UNKNOWN;
		byte[] b = null;
		if (wait == 0) wait = DEFAULT_RETRIES;
		if (state > 0) {
			for (int i = 1; i <= wait; i++) {
				currState = getState();
				debug("i = " + i + " and currState = " + currState);
				if (currState == state) break;
				try {
					/* Sleep only a short time between state
				   	checks .*/
					Thread.sleep(MISAL_SHORT_THREAD_SLEEP_INTERVAL);
				}
				catch (InterruptedException ie) {}
			}
			if (currState != state) {
				switch (state) {
					case ENABLE_MODE:
						this.doEnable();
						break;
					case DISABLE_MODE:
						this.doDisable();
						break;
					case CONFIG_MODE:
						this.doConfig();
						break;
					default:
						throw new IllegalMISALStateException("Needed state " + state + ", but found state " + currState);
				}
			}
			/* This check is really redundant. */
			if (getState() != state) {
				throw new IllegalMISALStateException("Unable to set the desired state.");
			}
		}
		b = new byte[data.length()];
		b = data.getBytes();
		debug("Sending data " + data);
		getOutputStream().write(b, 0, b.length);
		getOutputStream().flush();
		/* When sending a command, set the state to unknown.  It might
		   be better to think of this as pending until we can check
		   the new state. */
		setState(MISAL_STATE_UNKNOWN);
		if (expect != null) {
			debug("Expecting \"" + expect + "\"");
			result = expect(expect, wait);
		}
		else {
			debug("Expecting state: " + expectState);
			result = expect(expectState, wait);
		}
		if (!result) {
			throw new IllegalMISALStateException("Unable to reach expected state.");
		}
	}
        
        /** Start the MISAL state watcher thread.  This method should never be called directly.  It is run automatically once a new <CODE>MISALCiscoIOS</CODE> class is instantiated.
         */        
        public void run() {
			super.run();
d113 300
a412 1
        
@


1.11
log
@Fix bug with newer versions of IOS.  Now we're a little smarter when it comes
to reading in the telnet data.
@
text
@d27 1
a27 1
 * $Id: MISALCiscoIOS.java,v 1.10 2001/11/17 02:58:03 jmarcus Exp $
d31 1
a31 1
import com.oroinc.text.regex.*;
d37 1
a37 1
 * @@version $Id: MISALCiscoIOS.java,v 1.10 2001/11/17 02:58:03 jmarcus Exp $
@


1.10
log
@Fix up for release 1.0.1.  This release includes a major fix in MISALCiscoIOS
that kept it from working.
@
text
@d27 1
a27 1
 * $Id: MISALCiscoIOS.java,v 1.9 2001/11/06 01:05:03 jmarcus Exp $
d37 1
a37 1
 * @@version $Id: MISALCiscoIOS.java,v 1.9 2001/11/06 01:05:03 jmarcus Exp $
d110 2
a111 2
			addState(this.USER_PROMPT, "^Username:\\s.*$");
			addState(this.PASSWORD_PROMPT, "^Password:\\s.*$");
@


1.9
log
@Update documentation and Makefile to prepare for 1.0 release.
@
text
@d27 1
a27 1
 * $Id: MISALCiscoIOS.java,v 1.8 2001/11/05 05:44:25 jmarcus Exp $
d37 1
a37 1
 * @@version $Id: MISALCiscoIOS.java,v 1.8 2001/11/05 05:44:25 jmarcus Exp $
d410 1
@


1.8
log
@Finished adding documentation.
@
text
@d27 1
a27 1
 * $Id: MISALCiscoIOS.java,v 1.7 2001/10/21 02:39:09 jmarcus Exp $
a35 1
 * @@see MISAL
d37 1
a37 1
 * @@version $Id: MISALCiscoIOS.java,v 1.7 2001/10/21 02:39:09 jmarcus Exp $
d42 1
a42 1
     * '>').
a89 2
         * @@see MISAL#
         * @@see java.net.Socket#
d120 2
a121 2
         * @@see setVtyPassword(String)
         * @@see setUserPassword(String)
d129 1
a129 1
         * @@see setUserPassword(String)
d144 1
a144 1
         * @@see setUsername(String)
d153 1
a153 1
         * @@see setPasswordPrompt(String)
d162 1
a162 1
         * @@see setUsernamePrompt(String)
d170 1
a170 1
         * @@see errorOccurred()
d216 3
a218 3
         * @@see doEnable()
         * @@see doDisable()
         * @@see doConfig()
d247 2
a248 2
         * @@see doDisable()
         * @@see doConfig()
d272 1
a272 1
         * @@see doEnable()
d295 2
a296 2
         * @@see doEnable()
         * @@see doDisable()
d321 1
a321 1
         * @@see getLastErrorMessage()
d346 1
a346 1
         * @@see com.marcuscom.MISAL.MISAL.send(int,String,String,int,int)
@


1.7
log
@More JavaDoc stuff (now with Forte!).
@
text
@d27 1
a27 1
 * $Id$
d38 1
a38 1
 * @@version $Id$
d46 2
d49 2
d52 2
d55 2
d58 2
d61 2
d65 2
d68 2
d71 2
d74 2
d77 2
d80 2
d90 8
d121 5
d130 4
d138 3
d145 4
d153 5
d162 5
d171 4
d215 8
d247 6
d272 5
d295 6
d322 4
d341 10
d410 2
@


1.6
log
@Added a new method for accessing an IOS error message.  If the last command
returned with an error, the error message can be retrieved.
@
text
@d2 27
a28 1

d33 8
d42 3
d308 4
@


1.5
log
@Updated MISALCiscoIOS to remove methods that were already present in MISAL
that didn't need to be overridden.

Removed the MalformedPatternException from addState().  This way, casual
classes that make use of MISAL do not need to require
com.oroinc.text.regex.MalformedPatternException.
@
text
@d27 1
d76 8
d203 1
a203 1
			pattern = compiler.compile("^% ");
d207 1
@


1.4
log
@Improved the error checking code.  Also improved sending commands that
do not change the current state.
@
text
@d48 1
a48 1
		catch (MalformedPatternException mfpe) {}
d67 1
a67 1
	public void setUserPrompt(String prompt) throws MalformedPatternException {
d71 1
a71 1
	public void setPasswordPrompt(String prompt) throws MalformedPatternException {
a202 13

	public void send(int state, String data, int expectState) throws IllegalMISALStateException, IOException {
		this.send(state, data, null, expectState, 0);
	}

	public void send(String data, String expect) throws IllegalMISALStateException, IOException {
		this.send(MISAL_STATE_UNKNOWN, data, expect, 0, 0);
	}

	public void send(String data, int expectState) throws IllegalMISALStateException, IOException {
		this.send(MISAL_STATE_UNKNOWN, data, null, expectState, 0);
	}

@


1.3
log
@Fixed the *prompt API.  Now, there is one password prompt and one username
prompt.  I may have to add some code to handle a custom enable prompt as
well.

This is the first revision of MISALCiscoIOS that actually does what it's
supposed to ;-).
@
text
@d5 1
a5 1
import com.oroinc.text.regex.MalformedPatternException;
d189 15
d258 4
@


1.2
log
@Update the Cisco IOS class to match the new API in MISAL.
@
text
@d13 2
a14 4
	public static final int VTY_PROMPT = 6;
	public static final int USER_PROMPT = 7;
	public static final int PASSWORD_PROMPT = 8;
	public static final int ENABLE_PROMPT = 9;
a31 1

d34 1
a34 1
			addState(this.DISABLE_MODE, "> ?$"); 
d36 1
a36 1
			addState(this.ENABLE_MODE, "[^\\)]# ?$"); 
d38 1
a38 1
			addState(this.CONFIG_MODE, "\\(config\\)# ?$");
d40 1
a40 1
			addState(this.CONFIG_MODE_IF, "\\(config-if\\)# ?$");
d42 3
a44 5
			addState(this.CONFIG_MODE_OTHER, "\\(config-[^i][^f]\\)# ?$");
			addState(this.VTY_PROMPT, "Password: ?$");
			addState(this.USER_PROMPT, "Username: ?$");
			addState(this.PASSWORD_PROMPT, "Password: ?$");
			addState(this.ENABLE_PROMPT, "Password: ?$");
d46 2
a107 3
		if (getState() != MISAL_STATE_INITIAL) {
			return;
		}
d111 1
a111 1
				send(this.VTY_PROMPT, this._vtyPw, this.DISABLE_MODE);
d119 2
a120 2
					send(this.USER_PROMPT, this._user, this.PASSWORD_PROMPT);
					send(this.PASSWORD_PROMPT, this._userPw, "[#>] ?$");
d124 1
a124 1
					send(this.VTY_PROMPT, this._vtyPw, this.DISABLE_MODE);
a126 1

d136 1
a136 1
				send("enable\r", this.ENABLE_PROMPT);
@


1.1
log
@Initial revision
@
text
@d30 2
a31 10
	public MISALCiscoIOS(Socket socket, int bufSize) throws SocketException, IOException {
		this(socket, false, bufSize);
	}

	public MISALCiscoIOS(Socket socket, boolean debug) throws SocketException, IOException {
		this(socket, debug, DEFAULT_BUFFER_SIZE);
	}

	public MISALCiscoIOS(Socket socket, boolean debug, int bufSize) throws SocketException, IOException {
		super(socket, debug, bufSize);
@


1.1.1.1
log
@Initial import into the COSI CVS Repository
@
text
@@
