head	1.14;
access;
symbols;
locks; strict;
comment	@# @;


1.14
date	2005.01.18.22.43.04;	author jmarcus;	state Exp;
branches;
next	1.13;

1.13
date	2005.01.18.22.10.29;	author jmarcus;	state Exp;
branches;
next	1.12;

1.12
date	2003.04.29.16.49.32;	author jmarcus;	state Exp;
branches;
next	1.11;

1.11
date	2003.04.29.16.47.10;	author jmarcus;	state Exp;
branches;
next	1.10;

1.10
date	2002.09.11.15.02.02;	author jmarcus;	state Exp;
branches;
next	1.9;

1.9
date	2001.08.17.15.10.10;	author jmarcus;	state Exp;
branches;
next	1.8;

1.8
date	2001.07.08.21.42.31;	author jmarcus;	state Exp;
branches;
next	1.7;

1.7
date	2001.07.08.19.15.13;	author jmarcus;	state Exp;
branches;
next	1.6;

1.6
date	2001.05.31.15.32.28;	author jmarcus;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.31.15.16.36;	author jmarcus;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.25.23.14.14;	author jmarcus;	state Exp;
branches;
next	1.3;

1.3
date	2001.05.24.04.32.36;	author jmarcus;	state Exp;
branches;
next	1.2;

1.2
date	2001.05.24.04.19.05;	author jmarcus;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.22.18.59.15;	author jmarcus;	state Exp;
branches;
next	;


desc
@@


1.14
log
@* Update copyright
* Add the correct encoding type to the form
* Add the bulk file input to the bulk file results screen
@
text
@#!/usr/bin/perl
#-
# Copyright (c) 2001-2005 Joe Marcus Clarke <marcus@@marcuscom.com>
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
#
# $Id: snmptransc.pl,v 1.13 2005/01/18 22:10:29 jmarcus Exp $
#

BEGIN {
        $ENV{'PATH'} = '/bin:/usr/bin';
        delete @@ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

        # This is the name of the script relative to the HTTP root.
        $ME = '/cgi-bin/snmptransc.pl';

        # This is is the server port to connect to for sending CGI parameters.
        $SERVER_PORT = 3333;

        # This is the address or IP address of the server.  By default,
	# localhost is used.
        $SERVER_ADDR = 'localhost';

        # This is the path to the walkres.pl command.
        $WALKRES_CMD = '/usr/local/bin/walkres.pl';
}

use strict;
use IO::Socket;
use CGI;
use POSIX qw(tmpnam);
use vars
    qw($rcsid $SERVER_ADDR $SERVER_PORT $ME $q $cookie $client $data $result $size $WALKRES_CMD);
use constant MAX_FILE_SIZE => 1_048_576;
use constant BUFFER_SIZE   => 16_384;

$rcsid = '$Id: snmptransc.pl,v 1.13 2005/01/18 22:10:29 jmarcus Exp $';

$| = 1;

$CGI::DISABLE_UPLOADS = 0;
$CGI::POST_MAX        = MAX_FILE_SIZE;

$q = new CGI;
$q->cgi_error
    and return_error("SNMP Translate Error", "Unable to parse CGI variables.");

if (defined($q->param('oid')) && $q->param('oid') eq "") {
        return_error("SNMP Translate Error",
                "You did not specify an object name or OID to translate.");
} elsif (defined($q->param('pattern')) && $q->param('pattern') eq "") {
        return_error("SNMP Search Error",
                "You did not specify a pattern for which to search.");
} elsif (defined($q->param('bulk_file')) && $q->param('bulk_file') eq "") {
        return_error("SNMP Bulk Translate Error",
                "You did not specify a source file to translate.");
}

# Make the user input ``oid'' string safe for Perl consumption.
# Don't escape everything since we need to allow for regular expressions.
my $oid = $q->param('oid');
$oid =~ s/([\~\`\&\;\"\<\>\'])//g;
$oid =~ s/\s//g;

if ($q->param('bg') eq "1") {
        return_error("Bad Regular Expression",
                "The regular expression <I>$oid</i> is not valid.")
            if (!(eval { 'snmp' =~ /$oid/i, 1 }));
}

$client = IO::Socket::INET->new(
        PeerPort => $SERVER_PORT,
        PeerAddr => $SERVER_ADDR,
        Type     => SOCK_STREAM,
        Proto    => 'tcp',
        Timeout  => 10
    )
    or return_error("Server Error", "Error communicating with server.");

my $results = "";

if (       defined($q->param('security'))
        || defined($q->cookie(-name => 'security')))
{

        my $security = "";
        if (defined($q->param('security'))) {
                $security = $q->param('security');
        } else {
                $security = $q->cookie(-name => 'security');
        }

        # Implement CHAP-like security
        use Digest::MD5 qw(md5_hex)
            ;    # This module is required for security to work.
        my $digest = md5_hex($security);
        send_data($client, "digest");
        $results = get_data($client);
        if ($results ne "403") {
                return_error(
                        "Server Error",
                        "Error initiating authentication with server (results = \"$results\")."
                );
        }
        send_data($client, $digest);
        $results = get_data($client);

        if ($results ne "200") {
                return_error(
                        "Server Error",
                        "Error authenticating with server (results = \"$results\")."
                );
        }

        # Use cookies to persist the security info.
        $cookie = $q->cookie(-name => "security", -value => $security);

        if (!defined($cookie)) {
                return_error(
                        "SNMP Translate Error",
                        "You do not have cookies enabled in your browser.  This application requires all cookies to be enabled."
                );
        }
}

if (defined($q->param('pattern'))) {
        my $pattern = $q->param('pattern');
        $pattern =~ s/([\~\`\&\;\"\<\>\'])/\\$1/g;

        send_data($client, "pattern");
        $results = get_data($client);
        if ($results ne "200") {
                return_error(
                        "Server Error",
                        "Error communicating with server (results = \"$results\")."
                );
        }
        send_data($client, "0");
        $results = get_data($client);

        if ($results ne "200") {
                return_error(
                        "Server Error",
                        "Error communicating with server (results = \"$results\")."
                );
        }
        send_data($client, "0");
        $results = get_data($client);

        if ($results ne "200") {
                return_error(
                        "Server Error",
                        "Error communicating with server (results = \"$results\")."
                );
        }

        send_data($client, $pattern);
        $results = get_data($client);

        if ($results ne "200") {
                return_error(
                        "Server Error",
                        "Error communicating with server (results = \"$results\")."
                );
        }
        send_data($client, $q->param('descr'));

        $results = get_data($client);
        if ($results eq "501") {
                return_error(
                        "Bad Regular Expression",
                        "The regular expression <I>"
                            . $q->param('pattern')
                            . "</i> is not valid."
                );
        } elsif ($results eq "404") {
                return_error(
                        "SNMP Search Error",
                        "No objects were found matching the pattern <I>"
                            . $q->param('pattern')
                            . "</i>.  Please alter your search pattern, and try again."
                );
        } elsif ($results eq "502") {
                return_error(
                        "SNMP Search Error",
                        "The server timed out before returning valid data.  Please try again with a more specific pattern."
                );
        } elsif ($results eq "500") {
                return_error("SNMP Search Error",
                        "Internal server error encountered.");
        }

        return_data($results);
        exit(0);
}

if (defined($q->param('bulk_file'))) {
        my $buffer = "";
        my $fh     = $q->upload('bulk_file');
        $results = "";

        if (defined($fh)) {
                my $tmp = "";

                while (read($fh, $tmp, BUFFER_SIZE)) {
                        $buffer .= $tmp;
                }
                undef $tmp;
        }

        $buffer =~ s/\015$//;
        $buffer =~ s/\032$//;

        my $tmpfile = "";
        do { $tmpfile = tmpnam() } while (-f $tmpfile);

        open(TMP, ">" . $tmpfile)
            or return_error("File Error",
                "Error opening $tmpfile for writing: $!.");
        print TMP $buffer;
        close(TMP);

        my $i = 0;
        my $pid;

        if (!defined($pid = open(CMD, "-|"))) {
                unlink($tmpfile);
                return_error("Fork Error", "Failed to fork $WALKRES_CMD: $!");
        }

        if ($pid) {
                while (<CMD>) {
                        s/\&/&amp;/g;
                        s/\</&lt;/g;
                        s/\>/&gt;/g;
                        s/\n/<br>/g;
                        $results .= $_;
                }
                close(CMD);
        } else {
                if (!exec($WALKRES_CMD, $tmpfile)) {
                        unlink($tmpfile);
                        return_error("Exec Error",
                                "Failed to exec $WALKRES_CMD: $!");
                }
        }

        unlink($tmpfile);
        return_data("<pre>$results</pre>");
        exit(0);
}

if ($q->param('xOps') eq "") {
        send_data($client, "simple");
        $results = get_data($client);
        if ($results ne "200") {
                return_error(
                        "Server Error",
                        "Error communicating with server (results = \"$results\")."
                );
        }
        send_data($client, "0") if ($q->param('bg') ne "1");
        send_data($client, "1") if ($q->param('bg') eq "1");
        $results = get_data($client);

        if ($results ne "200") {
                return_error(
                        "Server Error",
                        "Error communicating with server (results = \"$results\")."
                );
        }

        send_data($client, "0") if ($q->param('replace') ne "1");
        send_data($client, "1") if ($q->param('replace') eq "1");
        $results = get_data($client);

        if ($results ne "200") {
                return_error(
                        "Server Error",
                        "Error communicating with server (results = \"$results\")."
                );
        }

        send_data($client, $oid);
        $results = get_data($client);

        if ($results eq "404") {
                return_error(
                        "SNMP Translate Error",
                        "Unable to translate <I>$oid</i>.  The object was either not found or invalid."
                );
        } elsif ($results eq "502") {
                return_error(
                        "SNMP Translate Error",
                        "The server timed out before returning valid data.  Please try again with a more specific object."
                );
        } elsif ($results eq "500") {
                return_error("SNMP Search Error",
                        "Internal server error encountered.");
        }

        return_data($results);
} elsif ($q->param('xOps') eq "detail") {
        send_data($client, "detail");
        $results = get_data($client);
        if ($results ne "200") {
                return_error("Server Error",
                        "Error communicating with server.");
        }
        send_data($client, "0") if ($q->param('bg') ne "1");
        send_data($client, "1") if ($q->param('bg') eq "1");
        $results = get_data($client);

        if ($results ne "200") {
                return_error(
                        "Server Error",
                        "Error communicating with server (results = \"$results\")."
                );
        }

        send_data($client, "0") if ($q->param('replace') ne "1");
        send_data($client, "1") if ($q->param('replace') eq "1");
        $results = get_data($client);

        if ($results ne "200") {
                return_error(
                        "Server Error",
                        "Error communicating with server (results = \"$results\")."
                );
        }

        send_data($client, $oid);
        $results = get_data($client);

        if ($results eq "404") {
                return_error(
                        "SNMP Translate Error",
                        "Unable to translate <I>$oid</i>.  The object was either not found or invalid."
                );
        } elsif ($results eq "502") {
                return_error(
                        "SNMP Translate Error",
                        "The server timed out before returning valid data.  Please try again with a more specific object."
                );
        } elsif ($results eq "500") {
                return_error("SNMP Search Error",
                        "Internal server error encountered.");
        }

        return_data($results);
} elsif ($q->param('xOps') eq "tree") {
        send_data($client, "tree");
        $results = get_data($client);
        if ($results ne "200") {
                return_error("Server Error",
                        "Error communicating with server.");
        }
        send_data($client, "0") if ($q->param('bg') ne "1");
        send_data($client, "1") if ($q->param('bg') eq "1");
        $results = get_data($client);

        if ($results ne "200") {
                return_error(
                        "Server Error",
                        "Error communicating with server (results = \"$results\")."
                );
        }

        send_data($client, "0") if ($q->param('replace') ne "1");
        send_data($client, "1") if ($q->param('replace') eq "1");
        $results = get_data($client);

        if ($results ne "200") {
                return_error(
                        "Server Error",
                        "Error communicating with server (results = \"$results\")."
                );
        }

        send_data($client, $oid);
        $results = get_data($client);

        if ($results eq "404") {
                return_error(
                        "SNMP Translate Error",
                        "Unable to display tree for <I>$oid</i>.  The object was either not found or invalid."
                );
        } elsif ($results eq "502") {
                return_error(
                        "SNMP Translate Error",
                        "The server timed out before returning valid data.  Please try again with a more specific object."
                );
        } elsif ($results eq "500") {
                return_error("SNMP Search Error",
                        "Internal server error encountered.");
        }

        return_data($results);
}

$client->close();

sub return_error {
        my ($title, $message) = @@_;

        print "Content-type: text/html", "\n\n";

        print <<ERROR;
<H1>$title</H1>
<HR>$message</HR>
ERROR
        $client->close() if ($client);
        exit(0);
}

sub send_data {
        my ($client, $data) = @@_;
        my ($old_fh);

        $old_fh = select $client;
        $|      = 1;
        $data =~ s/\n/<br>/g;
        print $client $data . "\n";
        select $old_fh;
        $| = 1;
}

sub get_data {
        my ($client) = $_[0];
        my ($data);

        $data = <$client>;
        chop($data);
        $data =~ s/<br>/\n/g;
        return $data;
}

sub return_data {
        my ($data) = $_[0];

        print $q->header(-type => "text/html", -cookie => $cookie);
        print <<"EOH";
<head>
<title>SNMP Search &amp; Translate Results</title>
</head>
<body bgcolor="#FFFFFF">
<SCRIPT LANGUAGE="JavaScript">
<!-- //

function isBlank (s) {
        for (var i = 0; i < s.length; i++) {
                var c = s.charAt(i);
                if ((c != '') && (c != '\\n') && (c != '\\t')) return false;
        }
        return true;
}

function verifyTrans (f) {
	var oid = f.oid.value;

	if (isBlank(oid)) {
		alert("You must specify an object identifier or object name to translate.");
		return false;
	}

	return true;
}

function verifyBulk (f) {
	var file = f.bulk_file.value;

	if (isBlank(file)) {
		alert("You must specify a source file to translate.");
		return false;
	}

	return true;
}

function verifySearch (f) {
	var pattern = f.pattern.value;

	if (isBlank(pattern)) {
		alert("You must specify a search pattern.");
		return false;
	}

	return true;
}

// -->
</script>
EOH
        if (defined($q->param('oid'))) {
                print <<"EOH";

<H1>SNMP Translate</h1>

<P>
<TABLE BORDER="0">
<FORM NAME="snmptrans" METHOD="POST" ACTION="/cgi-bin/snmptransc.pl" onSubmit="
	return verifyTrans(this);
">
	<TR>
		<TD ALIGN="RIGHT"><B>Object Identifier or Object Name:</B> </TD>
		<TD ALIGN="LEFT"><INPUT TYPE="TEXT" NAME="oid"
		MAXLENGTH="120"></TD>
                <TD ALIGN="LEFT"><INPUT TYPE="CHECKBOX" NAME="bg" VALUE="1">
                <I>r.e.</I></TD>
<!--		<TD ALIGN="RIGHT"><INPUT TYPE="CHECKBOX" NAME="replace" VALUE="1">
		<I>replace</I></TD>-->

	</TR>
</TABLE>
<B><I>
<P>
	Translate Options
</P>
</I></B>
<TABLE BORDER="0">
	<TR>
		<TD><INPUT TYPE="RADIO" VALUE="" NAME="xOps">
		<B>Simple Translation
		<TD><INPUT TYPE="RADIO" VALUE="detail" NAME="xOps" CHECKED>
		<B>Detailed Translation</B></TD>
		<TD><INPUT TYPE="RADIO" VALUE="tree" NAME="xOps">
		<B>Tree Translation</B></TD>
	</TR>
</TABLE>
<P></p>
<TABLE BORDER="0">
	<TR ALIGN="CENTER">
		<TD ALIGN="LEFT"><INPUT TYPE="SUBMIT"
		NAME="action" VALUE="Translate"></TD>
		<TD ALIGN="RIGHT"><INPUT TYPE="RESET" VALUE="Cancel"></TD>
	</TR>
</TABLE>
</form>
EOH
        } elsif (defined($q->param('bulk_file'))) {
                print <<"EOH";
<H1>SNMP Bulk Translate</h1>

<TABLE BORDER="0">
<FORM METHOD=POST ACTION="/cgi-bin/snmptransc.pl" NAME="snmpbulktrans" onSubmit="
	return verifyBulk(this);
" enctype="multipart/form-data">
	<TR>
		<TD ALIGN="RIGHT"><B>Bulk Translate a File:</b> </td>
		<TD ALIGN="LEFT"><INPUT TYPE="FILE" NAME="bulk_file"></td>
	</tr>
</table>
<P></p>
<TABLE BORDER="0">
	<TR ALIGN="CENTER">
		<TD ALIGN="RIGHT"><INPUT TYPE="SUBMIT" NAME="action"
		VALUE="Translate File"></td>
		<TD ALIGN="LEFT"><INPUT TYPE="RESET" VALUE="Cancel"></td>
	</tr>
</table>
</form>
EOH
        } else {
                print <<"EOH";
<H1>SNMP Search</h1>

<TABLE BORDER="0">
<FORM METHOD=POST ACTION="/cgi-bin/snmptransc.pl" NAME="snmpsearch" onSubmit="
	return verifySearch(this);
">
	<TR>
		<TD ALIGN="RIGHT"><B>Search Pattern:</b> </td>
		<TD ALIGN="LEFT"><INPUT TYPE="TEXT" NAME="pattern"
		MAXLENGTH="120"></td>
		<TD ALIGN="LEFT"><INPUT TYPE="CHECKBOX" NAME="descr" VALUE="1">
		<SMALL><I>Search description</I></SMALL></TD>

	</tr>
</table>
<P></p>
<TABLE BORDER="0">
	<TR ALIGN="CENTER">
		<TD ALIGN="RIGHT"><INPUT TYPE="SUBMIT" NAME="action"
		VALUE="Find Objects"></td>
		<TD ALIGN="LEFT"><INPUT TYPE="RESET" VALUE="Cancel"></td>
	</tr>
</table>
</form>
EOH
        }
        print <<"EOH";
<P>
</p>

<hr>

<h1>Results</h1>

$data

</body>
</html>
EOH
}

@


1.13
log
@Add support for bulk translations using Omer Ansari's walkres tool.
@
text
@d3 1
a3 1
# Copyright (c) 2001 Joe Clarke <marcus@@marcuscom.com>
d27 1
a27 1
# $Id: snmptransc.pl,v 1.12 2003/04/29 16:49:32 jmarcus Exp $
d40 2
a41 2
        # This is the address or IP address of the server.  By default, localhost
        # is used.
d43 3
d53 1
a53 1
    qw($rcsid $SERVER_ADDR $SERVER_PORT $ME $q $cookie $client $data $result $size);
d57 1
a57 1
$rcsid = '$Id: snmptransc.pl,v 1.12 2003/04/29 16:49:32 jmarcus Exp $';
d218 2
a219 3
        my $buffer  = "";
        my $fh      = $q->upload('bulk_file');
        my $command = '/usr/local/bin/walkres.pl';
a230 2
        close($fh);

d248 1
a248 1
                return_error("Fork Error", "Failed to fork $command: $!");
d256 1
d261 1
a261 1
                if (!exec($command, $tmpfile)) {
d264 1
a264 1
                                "Failed to exec $command: $!");
d269 1
a269 1
        return_data($results);
d489 11
d560 23
d597 1
a597 1
		
@


1.12
log
@Added one too many '\'.
@
text
@d27 1
a27 1
# $Id: snmptransc.pl,v 1.11 2003/04/29 16:47:10 jmarcus Exp $
d48 1
d51 2
d54 1
a54 1
$rcsid = '$Id: snmptransc.pl,v 1.11 2003/04/29 16:47:10 jmarcus Exp $';
d58 3
d71 3
d214 58
d505 1
a505 1
<H1>SNMP Translate Translate</h1>
d530 1
a530 1
		<TD><INPUT TYPE="RADIO" VALUE="" NAME="xOps" CHECKED>
d532 1
a532 1
		<TD><INPUT TYPE="RADIO" VALUE="detail" NAME="xOps">
@


1.11
log
@Escape \t and \n in the dynamically generated JavaScript.
@
text
@d27 1
a27 1
# $Id: snmptransc.pl,v 1.10 2002/09/11 15:02:02 jmarcus Exp $
d51 1
a51 1
$rcsid = '$Id: snmptransc.pl,v 1.10 2002/09/11 15:02:02 jmarcus Exp $';
d405 1
a405 1
                if ((c != '') && (c != '\\\n') && (c != '\\\t')) return false;
@


1.10
log
@Prepend the search or translate form at the top of each results page
so making subsequent queries is easier.
@
text
@d27 1
a27 1
# $Id: snmptransc.pl,v 1.9 2001/08/17 15:10:10 jmarcus Exp $
d51 1
a51 1
$rcsid = '$Id: snmptransc.pl,v 1.9 2001/08/17 15:10:10 jmarcus Exp $';
d405 1
a405 1
                if ((c != '') && (c != '\n') && (c != '\t')) return false;
@


1.9
log
@Fixed a bug in error reporting for bad patters.  Thanks to
alex@@ergens.op.HET.NET for discovering this.
@
text
@d27 1
a27 1
# $Id: snmptransc.pl,v 1.8 2001/07/08 21:42:31 jmarcus Exp $
d31 2
a32 2
    $ENV{'PATH'} = '/bin:/usr/bin';
    delete @@ENV{ 'IFS', 'CDPATH', 'ENV', 'BASH_ENV' };
d34 2
a35 2
    # This is the name of the script relative to the HTTP root.
    $ME = '/cgi-bin/snmptransc.pl';
d37 2
a38 2
    # This is is the server port to connect to for sending CGI parameters.
    $SERVER_PORT = 3333;
d40 3
a42 3
    # This is the address or IP address of the server.  By default, localhost
    # is used.
    $SERVER_ADDR = 'localhost';
d49 1
a49 1
  qw($rcsid $SERVER_ADDR $SERVER_PORT $ME $q $cookie $client $data $result $size);
d51 1
a51 1
$rcsid = '$Id: snmptransc.pl,v 1.8 2001/07/08 21:42:31 jmarcus Exp $';
d57 1
a57 1
  and return_error( "SNMP Translate Error", "Unable to parse CGI variables." );
d59 6
a64 7
if ( defined( $q->param('oid') ) && $q->param('oid') eq "" ) {
    return_error( "SNMP Translate Error",
        "You did not specify an object name or OID to translate." );
}
elsif ( defined( $q->param('pattern') ) && $q->param('pattern') eq "" ) {
    return_error( "SNMP Search Error",
        "You did not specify a pattern for which to search." );
d73 4
a76 4
if ( $q->param('bg') eq "1" ) {
    return_error( "Bad Regular Expression",
        "The regular expression <I>$oid</i> is not valid." )
      if ( !( eval { 'snmp' =~ /$oid/i, 1 } ) );
d80 7
a86 6
    PeerPort => $SERVER_PORT,
    PeerAddr => $SERVER_ADDR,
    Type     => SOCK_STREAM,
    Proto    => 'tcp',
    Timeout  => 10
) or return_error( "Server Error", "Error communicating with server." );
d90 2
a91 2
if ( defined( $q->param('security') )
  || defined( $q->cookie( -name => 'security' ) ) )
d94 255
a348 226
    my $security = "";
    if ( defined( $q->param('security') ) ) {
        $security = $q->param('security');
    }
    else {
        $security = $q->cookie( -name => 'security' );
    }

    # Implement CHAP-like security
    use Digest::MD5 qw(md5_hex);    # This module is required for security to work.
    my $digest = md5_hex($security);
    send_data( $client, "digest" );
    $results = get_data($client);
    if ( $results ne "403" ) {
        return_error( "Server Error",
"Error initiating authentication with server (results = \"$results\")."
        );
    }
    send_data( $client, $digest );
    $results = get_data($client);

    if ( $results ne "200" ) {
        return_error( "Server Error",
            "Error authenticating with server (results = \"$results\")." );
    }

    # Use cookies to persist the security info.
    $cookie = $q->cookie( -name => "security", -value => $security );

    if ( !defined($cookie) ) {
        return_error( "SNMP Translate Error",
"You do not have cookies enabled in your browser.  This application requires all cookies to be enabled."
        );
    }
}

if ( defined( $q->param('pattern') ) ) {
    my $pattern = $q->param('pattern');
    $pattern =~ s/([\~\`\&\;\"\<\>\'])/\\$1/g;

    send_data( $client, "pattern" );
    $results = get_data($client);
    if ( $results ne "200" ) {
        return_error( "Server Error",
            "Error communicating with server (results = \"$results\")." );
    }
    send_data( $client, "0" );
    $results = get_data($client);

    if ( $results ne "200" ) {
        return_error( "Server Error",
            "Error communicating with server (results = \"$results\")." );
    }
    send_data( $client, "0" );
    $results = get_data($client);

    if ( $results ne "200" ) {
        return_error( "Server Error",
            "Error communicating with server (results = \"$results\")." );
    }

    send_data( $client, $pattern );
    $results = get_data($client);

    if ( $results ne "200" ) {
        return_error( "Server Error",
            "Error communicating with server (results = \"$results\")." );
    }
    send_data( $client, $q->param('descr') );

    $results = get_data($client);
    if ( $results eq "501" ) {
        return_error( "Bad Regular Expression",
            "The regular expression <I>" . $q->param('pattern')
            . "</i> is not valid." );
    }
    elsif ( $results eq "404" ) {
        return_error( "SNMP Search Error",
            "No objects were found matching the pattern <I>"
            . $q->param('pattern')
            . "</i>.  Please alter your search pattern, and try again." );
    }
    elsif ( $results eq "502" ) {
        return_error( "SNMP Search Error",
"The server timed out before returning valid data.  Please try again with a more specific pattern."
        );
    }
    elsif ( $results eq "500" ) {
        return_error( "SNMP Search Error",
            "Internal server error encountered." );
    }

    return_data($results);
    exit(0);
}

if ( $q->param('xOps') eq "" ) {
    send_data( $client, "simple" );
    $results = get_data($client);
    if ( $results ne "200" ) {
        return_error( "Server Error",
            "Error communicating with server (results = \"$results\")." );
    }
    send_data( $client, "0" ) if ( $q->param('bg') ne "1" );
    send_data( $client, "1" ) if ( $q->param('bg') eq "1" );
    $results = get_data($client);

    if ( $results ne "200" ) {
        return_error( "Server Error",
            "Error communicating with server (results = \"$results\")." );
    }

    send_data( $client, "0" ) if ( $q->param('replace') ne "1" );
    send_data( $client, "1" ) if ( $q->param('replace') eq "1" );
    $results = get_data($client);

    if ( $results ne "200" ) {
        return_error( "Server Error",
            "Error communicating with server (results = \"$results\")." );
    }

    send_data( $client, $oid );
    $results = get_data($client);

    if ( $results eq "404" ) {
        return_error( "SNMP Translate Error",
"Unable to translate <I>$oid</i>.  The object was either not found or invalid."
        );
    }
    elsif ( $results eq "502" ) {
        return_error( "SNMP Translate Error",
"The server timed out before returning valid data.  Please try again with a more specific object."
        );
    }
    elsif ( $results eq "500" ) {
        return_error( "SNMP Search Error",
            "Internal server error encountered." );
    }

    return_data($results);
}
elsif ( $q->param('xOps') eq "detail" ) {
    send_data( $client, "detail" );
    $results = get_data($client);
    if ( $results ne "200" ) {
        return_error( "Server Error", "Error communicating with server." );
    }
    send_data( $client, "0" ) if ( $q->param('bg') ne "1" );
    send_data( $client, "1" ) if ( $q->param('bg') eq "1" );
    $results = get_data($client);

    if ( $results ne "200" ) {
        return_error( "Server Error",
            "Error communicating with server (results = \"$results\")." );
    }

    send_data( $client, "0" ) if ( $q->param('replace') ne "1" );
    send_data( $client, "1" ) if ( $q->param('replace') eq "1" );
    $results = get_data($client);

    if ( $results ne "200" ) {
        return_error( "Server Error",
            "Error communicating with server (results = \"$results\")." );
    }

    send_data( $client, $oid );
    $results = get_data($client);

    if ( $results eq "404" ) {
        return_error( "SNMP Translate Error",
"Unable to translate <I>$oid</i>.  The object was either not found or invalid."
        );
    }
    elsif ( $results eq "502" ) {
        return_error( "SNMP Translate Error",
"The server timed out before returning valid data.  Please try again with a more specific object."
        );
    }
    elsif ( $results eq "500" ) {
        return_error( "SNMP Search Error",
            "Internal server error encountered." );
    }

    return_data($results);
}
elsif ( $q->param('xOps') eq "tree" ) {
    send_data( $client, "tree" );
    $results = get_data($client);
    if ( $results ne "200" ) {
        return_error( "Server Error", "Error communicating with server." );
    }
    send_data( $client, "0" ) if ( $q->param('bg') ne "1" );
    send_data( $client, "1" ) if ( $q->param('bg') eq "1" );
    $results = get_data($client);

    if ( $results ne "200" ) {
        return_error( "Server Error",
            "Error communicating with server (results = \"$results\")." );
    }

    send_data( $client, "0" ) if ( $q->param('replace') ne "1" );
    send_data( $client, "1" ) if ( $q->param('replace') eq "1" );
    $results = get_data($client);

    if ( $results ne "200" ) {
        return_error( "Server Error",
            "Error communicating with server (results = \"$results\")." );
    }

    send_data( $client, $oid );
    $results = get_data($client);

    if ( $results eq "404" ) {
        return_error( "SNMP Translate Error",
"Unable to display tree for <I>$oid</i>.  The object was either not found or invalid."
        );
    }
    elsif ( $results eq "502" ) {
        return_error( "SNMP Translate Error",
"The server timed out before returning valid data.  Please try again with a more specific object."
        );
    }
    elsif ( $results eq "500" ) {
        return_error( "SNMP Search Error",
            "Internal server error encountered." );
    }
d350 1
a350 1
    return_data($results);
d356 1
a356 1
    my ( $title, $message ) = @@_;
d358 1
a358 1
    print "Content-type: text/html", "\n\n";
d360 1
a360 1
    print <<ERROR;
d364 2
a365 2
    $client->close() if ($client);
    exit(0);
d369 2
a370 2
    my ( $client, $data ) = @@_;
    my ($old_fh);
d372 6
a377 6
    $old_fh = select $client;
    $|      = 1;
    $data =~ s/\n/<br>/g;
    print $client $data . "\n";
    select $old_fh;
    $| = 1;
d381 2
a382 2
    my ($client) = $_[0];
    my ($data);
d384 4
a387 4
    $data = <$client>;
    chop($data);
    $data =~ s/<br>/\n/g;
    return $data;
d391 1
a391 1
    my ($data) = $_[0];
d393 123
a515 3
    print $q->header( -type => "text/html", -cookie => $cookie );
    print <<"EOH";
<BODY BGCOLOR="#FFFFFF">
@


1.8
log
@Fixed up the new alarm clock code.  It actually returns the correct
error now.  Also, lowered the timer from 10 minutes to 5 minutes.  Most
browsers will give up by 10 minutes anyway.
@
text
@d27 1
a27 1
# $Id: snmptransc.pl,v 1.7 2001/07/08 19:15:13 jmarcus Exp $
d51 1
a51 1
$rcsid = '$Id: snmptransc.pl,v 1.7 2001/07/08 19:15:13 jmarcus Exp $';
d167 2
a168 2
            "The regular expression <I>$q->param('pattern')</i> is not valid."
        );
d172 3
a174 2
"No objects were found matching the pattern <I>$q->param('pattern')</i>.  Please alter your search pattern, and try again."
        );
@


1.7
log
@Added support for an alarm timer.  This way, if the translate/search operation
is taking too long, the timer will abort it.  This avoids denial of service
attacks if the MIB tree is very large.
@
text
@d27 1
a27 1
# $Id: snmptransc.pl,v 1.6 2001/05/31 15:32:28 jmarcus Exp $
d51 1
a51 1
$rcsid = '$Id: snmptransc.pl,v 1.6 2001/05/31 15:32:28 jmarcus Exp $';
d180 4
d227 4
d271 4
d314 4
@


1.6
log
@Fixed bugs in previous commit.  I _really_ need to clean up the cient/server
code.  I just don't have the time now.
@
text
@d27 1
a27 1
# $Id: snmptransc.pl,v 1.5 2001/05/31 15:16:36 jmarcus Exp $
d49 1
a49 1
qw($rcsid $SERVER_ADDR $SERVER_PORT $ME $q $cookie $client $data $result $size);
d51 1
a51 1
$rcsid = '$Id: snmptransc.pl,v 1.5 2001/05/31 15:16:36 jmarcus Exp $';
d61 1
a61 1
      "You did not specify an object name or OID to translate." );
d65 1
a65 1
      "You did not specify a pattern for which to search." );
d76 1
a76 1
      "The regular expression <I>$oid</i> is not valid." )
d81 6
a86 6
  PeerPort => $SERVER_PORT,
  PeerAddr => $SERVER_ADDR,
  Type     => SOCK_STREAM,
  Proto    => 'tcp',
  Timeout  => 10 )
  or return_error( "Server Error", "Error communicating with server." );
d109 1
a109 1
         "Error initiating authentication with server (results = \"$results\")."
d117 1
a117 1
          "Error authenticating with server (results = \"$results\")." );
d138 1
a138 1
          "Error communicating with server (results = \"$results\")." );
d145 1
a145 1
          "Error communicating with server (results = \"$results\")." );
d152 1
a152 1
          "Error communicating with server (results = \"$results\")." );
d160 1
a160 1
          "Error communicating with server (results = \"$results\")." );
d167 2
a168 1
          "The regular expression <I>$q->param('pattern')</i> is not valid." );
d175 5
d190 1
a190 1
          "Error communicating with server (results = \"$results\")." );
d198 1
a198 1
          "Error communicating with server (results = \"$results\")." );
d207 1
a207 1
          "Error communicating with server (results = \"$results\")." );
d218 5
d238 1
a238 1
          "Error communicating with server (results = \"$results\")." );
d247 1
a247 1
          "Error communicating with server (results = \"$results\")." );
d258 5
d278 1
a278 1
          "Error communicating with server (results = \"$results\")." );
d287 1
a287 1
          "Error communicating with server (results = \"$results\")." );
d296 5
@


1.5
log
@Added support for telling the MIB parser to replace older loaded MIB objects
with newer ones.  Note: this requires my patches to SNMP.pm which have
not yet been introduced in the official net-snmp CVS repository.

This feature will not be rolled into a release until the patch becomes
official.
@
text
@d27 1
a27 1
# $Id: snmptransc.pl,v 1.4 2001/05/25 23:14:14 jmarcus Exp $
d51 1
a51 1
$rcsid = '$Id: snmptransc.pl,v 1.4 2001/05/25 23:14:14 jmarcus Exp $';
d141 1
d148 1
a154 1
    $results = get_data($client);
d188 1
d197 1
a203 1
    $results = get_data($client);
d223 1
d232 1
a238 1
    $results = get_data($client);
d258 1
d267 1
a273 1
    $results = get_data($client);
@


1.4
log
@Updated the CGI component to make security persistent by using cookies.

A new requirement is CGI.pm.  This is pretty standard, so I don't anticipate
this will hurt anyone.
@
text
@d27 1
a27 1
# $Id: snmptransc.pl,v 1.3 2001/05/24 04:32:36 jmarcus Exp $
d51 1
a51 1
$rcsid = '$Id: snmptransc.pl,v 1.3 2001/05/24 04:32:36 jmarcus Exp $';
d121 1
a121 2
    $cookie =
      $q->cookie( -name => "security", -value => $security );
d146 7
d192 9
d226 9
d260 9
@


1.3
log
@Chase down bugs in my previous commit.

This revision actually has the security working.  Again, there should be
more sanity checking in the client/server conversation.  I will get to
that if someone doesn't beat me to it.
@
text
@d27 1
a27 1
# $Id: snmptransc.pl,v 1.2 2001/05/24 04:19:05 jmarcus Exp $
d32 1
d47 1
d49 1
a49 1
 qw($rcsid $SERVER_ADDR $SERVER_PORT $ME %contents $client $data $result $size);
d51 1
a51 1
$rcsid = '$Id: snmptransc.pl,v 1.2 2001/05/24 04:19:05 jmarcus Exp $';
d55 3
a57 2
# Insure POST method
if ( $ENV{'REQUEST_METHOD'} eq 'POST' ) {
d59 1
a59 43
    # Count the bytes received
    my $buffer;
    read( STDIN, $buffer, $ENV{'CONTENT_LENGTH'} );

    # make list of name/value pairs
    my @@pairs = split ( /&/, $buffer );
    my $pair;

    # cycle through each pair and parse
    foreach $pair (@@pairs) {

        # get the name/value pair
        my ( $name, $value ) = split ( /=/, $pair );

        # translate "+" to white space
        $value =~ tr/+/ /;

        # translate ASCII hex escaped characters if any
        $value =~ s/%([a-fA-F0-9][a-fA-F0-9])/pack("C", hex($1))/eg;

        # add the pair to a list marked on the name of the variable
        if ( defined( $contents{$name} ) ) {
            $contents{$name} = join ( "\0", $contents{$name}, $value );
        }
        else {
            $contents{$name} = $value;
        }
    }
}
elsif ( $ENV{'REQUEST_METHOD'} eq 'GET' ) {    # Do the same thing for GET.
    my @@pairs = split ( /&/, $ENV{'QUERY_STRING'} );
    my $pair;

    foreach $pair (@@pairs) {
        $pair =~ tr/+/ /;
        $pair =~ s/%([a-fA-F0-9][a-fA-F-0-9])/pack("C",hex($1))/eg;
        my ( $name, $value ) = split ( /=/, $pair );
        $value = 1 if ( !defined($value) );
        $contents{$name} = $value;
    }
}

if ( defined( $contents{'oid'} ) && $contents{'oid'} eq "" ) {
d63 1
a63 1
elsif ( defined( $contents{'pattern'} ) && $contents{'pattern'} eq "" ) {
d70 3
a72 2
$contents{'oid'} =~ s/([\~\`\&\;\"\<\>\'])//g;
$contents{'oid'} =~ s/\s//g;
d74 1
a74 1
if ( $contents{'bg'} eq "1" ) {
d76 2
a77 2
      "The regular expression <I>$contents{'oid'}</i> is not valid." )
      if ( !( eval { 'snmp' =~ /$contents{'oid'}/i, 1 } ) );
d90 11
a100 1
if ( defined( $contents{'security'} ) ) {
d104 1
a104 1
    my $digest = md5_hex( $contents{'security'} );
d119 10
d131 4
a134 1
if ( defined( $contents{'pattern'} ) ) {
d148 1
a148 1
    send_data( $client, $contents{'pattern'} );
d155 1
a155 1
    send_data( $client, $contents{'descr'} );
d160 1
a160 1
          "The regular expression <I>$contents{'pattern'}</i> is not valid." );
d164 1
a164 1
"No objects were found matching the pattern <I>$contents{'pattern'}</i>.  Please alter your search pattern, and try again."
d172 1
a172 1
if ( $contents{'xOps'} eq "" ) {
d179 2
a180 2
    send_data( $client, "0" ) if ( $contents{'bg'} ne "1" );
    send_data( $client, "1" ) if ( $contents{'bg'} eq "1" );
d187 1
a187 1
    send_data( $client, $contents{'oid'} );
d192 1
a192 1
"Unable to translate <I>$contents{'oid'}</i>.  The object was either not found or invalid."
d198 1
a198 1
elsif ( $contents{'xOps'} eq "detail" ) {
d204 2
a205 2
    send_data( $client, "0" ) if ( $contents{'bg'} ne "1" );
    send_data( $client, "1" ) if ( $contents{'bg'} eq "1" );
d212 1
a212 1
    send_data( $client, $contents{'oid'} );
d217 1
a217 1
"Unable to translate <I>$contents{'oid'}</i>.  The object was either not found or invalid."
d223 1
a223 1
elsif ( $contents{'xOps'} eq "tree" ) {
d229 2
a230 2
    send_data( $client, "0" ) if ( $contents{'bg'} ne "1" );
    send_data( $client, "1" ) if ( $contents{'bg'} eq "1" );
d237 1
a237 1
    send_data( $client, $contents{'oid'} );
d242 1
a242 1
"Unable to display tree for <I>$contents{'oid'}</i>.  The object was either not found or invalid."
d289 2
a290 3
    print <<EOH;
Content-type: text/html

@


1.2
log
@Added some initial security code.

This code sort of works like CHAP, and requires the Digest::MD5 Perl module.
It's not perfect yet, but this is a start.
@
text
@d27 1
a27 1
# $Id: snmptransc.pl,v 1.1 2001/05/22 18:59:15 jmarcus Exp $
d49 1
a49 1
$rcsid = '$Id: snmptransc.pl,v 1.1 2001/05/22 18:59:15 jmarcus Exp $';
d131 2
a132 2
    use Digest::MD5 qw(md5);    # This module is required for security to work.
    my $digest = md5( $contents{'security'} );
@


1.1
log
@These files make up the contents of the previously committed tar.gz file.
This is a CGI frontend to net-snmp's snmptranslate command.
@
text
@d27 1
a27 1
# $Id: snmptransc.pl,v 1.1 2001/05/21 19:59:57 marcus Exp $
d49 1
a49 1
$rcsid = '$Id: snmptransc.pl,v 1.1 2001/05/21 19:59:57 marcus Exp $';
d127 21
@

