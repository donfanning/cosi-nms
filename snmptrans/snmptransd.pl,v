head	1.13;
access;
symbols;
locks; strict;
comment	@# @;


1.13
date	2003.12.24.18.40.25;	author jmarcus;	state Exp;
branches;
next	1.12;

1.12
date	2003.09.30.22.00.20;	author jmarcus;	state Exp;
branches;
next	1.11;

1.11
date	2003.09.30.21.41.13;	author jmarcus;	state Exp;
branches;
next	1.10;

1.10
date	2003.07.17.06.31.06;	author jmarcus;	state Exp;
branches;
next	1.9;

1.9
date	2001.08.22.13.12.45;	author jmarcus;	state Exp;
branches;
next	1.8;

1.8
date	2001.08.16.05.59.23;	author jmarcus;	state Exp;
branches;
next	1.7;

1.7
date	2001.07.08.21.42.31;	author jmarcus;	state Exp;
branches;
next	1.6;

1.6
date	2001.07.08.19.15.13;	author jmarcus;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.31.15.32.28;	author jmarcus;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.31.15.16.36;	author jmarcus;	state Exp;
branches;
next	1.3;

1.3
date	2001.05.24.04.32.36;	author jmarcus;	state Exp;
branches;
next	1.2;

1.2
date	2001.05.24.04.19.05;	author jmarcus;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.22.18.59.15;	author jmarcus;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Fix a bug where objects with no type would not display correctly.
@
text
@#!/usr/bin/perl
#-
# Copyright (c) 2001 Joe Clarke <marcus@@marcuscom.com>
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
#
# $Id: snmptransd.pl,v 1.12 2003/09/30 22:00:20 jmarcus Exp $
#

BEGIN {
        $ENV{'PATH'} = '/bin:/usr/bin';

        # Set LD_LIBRARY_PATH to the location of the net-snmp (ucd-snmp) libraries.
        #$ENV{'LD_LIBRARY_PATH'} = '';

        # Zero out all previous environment variables.
        $ENV{'MIBS'}    = '';
        $ENV{'MIBDIRS'} = '';

        $MIBS = 'ALL';

        # Set this directory to the location where your MIBs are stored.
        $MIBDIRS = '/usr/local/share/snmp/mibs';

        # This is the name of the client CGI piece.  It should be a relative path
        # from the HTTP root.
        $ME = '/cgi-bin/snmptransc.pl';

        # Specify the location of the pidfile.  This is where the process id of the
        # server parent will be written to.  This is usually /var/run.
        $PIDFILE = '/var/run/snmptransd.pid';

        # Specify the local port for the server to bind to.  This is 3333
        # by default.
        $LOCAL_PORT = 3333;

        # Specify the number of seconds to wait before throwing a timeout exception.
        # This helps avoid denial of service attacks if the MIB tree is large.  The
        # default is 5 minutes.
        $TIMEOUT_SECS = 300;

        # Enable CHAP-like security for connecting to the server process.  This is
        # disable by default.  Set this to the name of the password file to
        # enable security.
        $SECURITY = "";

        # Enable global MIB module replacement.  This is a parsing option that tells
        # net-snmp to replace older loaded MIB modules with newer ones.  This can
        # overwrite older, less-descriptive, MIB objects with newer, more
        # descriptive ones (e.g. ifOperStatus from RFC1213 and IF).
        # WARNING: this can cause an inconsistent MIB hierarchy.  Use this option
        # with care.
        $REPLACE = 0;
}

use strict;
use vars
    qw($rcsid $SECURITY $PIDFILE $TIMEOUT_SECS $LOCAL_PORT $REPLACE $server $MAXLEN $PREFORK $MAX_CLIENTS_PER_CHILD %children $children $ME $MIBS $MIBDIRS $HTTPMIBS %contents @@leave_indent $leave_was_simple $tree_buffer $last_ip);
use IO::Socket;
use Symbol;

use SNMP;
$SNMP::save_descriptions = 1;
$SNMP::replace_newer     = 1 if ($REPLACE);
$SNMP::use_long_names    = 1;
$SNMP::use_enums         = 1;
SNMP::initMib();
SNMP::addMibDirs($MIBDIRS);
SNMP::loadModules($MIBS);
use POSIX;

sub LOCK_SH { 1 }
sub LOCK_EX { 2 }
sub LOCK_NB { 4 }
sub LOCK_UN { 8 }

$rcsid = '$Id: snmptransd.pl,v 1.12 2003/09/30 22:00:20 jmarcus Exp $';

$server = IO::Socket::INET->new(
        LocalPort => $LOCAL_PORT,
        Type      => SOCK_STREAM,
        Proto     => 'tcp',
        Reuse     => 1,
        Listen    => 10
    )
    or die "Error creating socket: $@@\n";

if (-f $PIDFILE) {
        unless (open(PID, $PIDFILE)) {
                die "Unable to open $PIDFILE for reading: $!\n";
        }
        my $pid = <PID>;
        print "Server already running as process $pid.\n";
        close(PID);
        exit(1);
}

unless (open(PID, ">" . $PIDFILE)) {
        die "Unable to open $PIDFILE for writing: $!\n";
}
flock(PID, LOCK_EX);

print PID $$;

close(PID);

print "Server ready ...\n";

$MAXLEN                = 1024;
$PREFORK               = 5;
$MAX_CLIENTS_PER_CHILD = 5;
%children              = ();
$children              = 0;

$| = 1;

sub REAPER {
        $SIG{CHLD} = \&REAPER;
        my $pid = wait;
        $children--;
        delete $children{$pid};
}

sub HUNTSMAN {
        local ($SIG{CHLD}) = 'IGNORE';
        kill 'INT' => keys %children;
        CLEANUP();
}

sub CLEANUP {
        unlink $PIDFILE;
        exit(0);
}

for (1 .. $PREFORK) {
        make_new_child();
}

# Set up default signal handlers.  Not sure what this will do on Windows.
$SIG{CHLD} = \&REAPER;
$SIG{INT}  = \&HUNTSMAN;
$SIG{TERM} = \&HUNTSMAN;

while (1) {
        sleep;
        my $i;
        for ($i = $children ; $i < $PREFORK ; $i++) {
                make_new_child();
        }
}

sub make_new_child {
        my $pid;
        my $sigset;

        $sigset = POSIX::SigSet->new(SIGINT);
        sigprocmask(SIG_BLOCK, $sigset)
            or die "Can't block SIGINT for fork: $!\n";

        die "fork: $!" unless defined($pid = fork);

        if ($pid) {
                sigprocmask(SIG_UNBLOCK, $sigset)
                    or die "Can't unblock SIGINT for fork: $!\n";
                $children{$pid} = 1;
                $children++;
                return;
        } else {
                $SIG{INT} = 'DEFAULT';

                # This signal handler controls what to do if the snmptrans operation
                # runs for too long.  We will catch this timeout, and return an error.
                $SIG{ALRM} = sub { die "timeout" };

                sigprocmask(SIG_UNBLOCK, $sigset)
                    or die "Can't unblock SIGINT for fork: $!\n";

                my $i;
                for ($i = 0 ; $i < $MAX_CLIENTS_PER_CHILD ; $i++) {
                        my $client = $server->accept() or last;
                        snmptrans($client);
                        $client->close() if ($client);
                }
        }
        exit;
}

sub snmptrans {
        my ($client) = $_[0];
        my ($bg, $replace, $type, $size, $request, $numeric);
        my $data;

        # XXX Make all the client/server code a little clearer.  By this, I should
        # have codes that trigger options being set, and codes that indicate data.
        # Right now, things are too messy.

        if ($SECURITY ne "") {
                use Digest::MD5 qw(md5_hex);
                unless (open(PW, $SECURITY)) {
                        die "Cannot open password file $SECURITY: $!\n";
                }

                my $pw = <PW>;

                close(PW);

                chomp $pw;

                $type = get_data($client);
                if ($type eq "digest") {
                        send_data($client, "403");
                } else {
                        send_data($client, "501");
                        return;
                }
                my $digest = get_data($client);

                if ($digest eq md5_hex($pw)) {
                        send_data($client, "200");
                } else {
                        send_data($client, "403");
                        return;
                }
        }

        $type = get_data($client);
        send_data($client, "200");
        $bg = get_data($client);
        send_data($client, "200");
        if ($bg eq "1") {
                $SNMP::best_guess = 1;
        }
        $replace = get_data($client);
        send_data($client, "200");
        $request = get_data($client);

        if ($replace eq "1") {
                $SNMP::replace_newer = 1;
        }

        if ($request =~ /^(\d+\.)+\d+$/) {
                $request = "." . $request;
                $numeric = 1;
        } elsif ($request =~ /^\.(\d+\.)+\d+$/) {
                $numeric = 1;
        }

        if ($type eq "pattern") {
                send_data($client, "200");
                my $search_descr = get_data($client);
                if (!(eval { 'snmp' =~ /$request/i, 1 })) {
                        send_data($client, "501");
                        return;
                }

                if ($search_descr eq "1") {
                        $search_descr = 1;
                } else {
                        $search_descr = 0;
                }
                my $mib        = $SNMP::MIB{'.1'};    # Start from the root.
                my @@occurances = ();
                eval {
                        alarm($TIMEOUT_SECS);
                        find_occurances($request, $search_descr, $mib,
                                \@@occurances);
                        alarm(0);
                };

                if ($@@) {
                        if ($@@ =~ /timeout/) {
                                send_data($client, "502");
                                return;
                        } else {
                                alarm(0);
                                send_data($client, "500");
                                return;
                        }
                }
                my ($occurance);

                if (!(scalar @@occurances)) {
                        send_data($client, "404");
                        return;
                }
                $data = "<H3>Found " . scalar @@occurances . " match(es)</h3>\n";
                $data .= "<TABLE BORDER=\"0\">\n";

                foreach $occurance (@@occurances) {
                        $data .= "<TR>\n";
                        my ($value, $isbranch) = split(/\|/, $occurance);
                        if ($isbranch) {
                                $data .= "<TD>$value</td>\n";
                                $data .=
                                    "<TD><SMALL>[<A HREF=\"$ME?oid=$value&xOps=detail\">detail</a>] | [<A HREF=\"$ME?oid=$value&xOps=tree\">tree</a>]</small></td>\n";
                        } else {
                                $data .= "<TD>$value</td>\n";
                                $data .=
                                    "<TD><SMALL>[<A HREF=\"$ME?oid=$value&xOps=detail\">detail</a>] | [<FONT COLOR=\"lightgrey\">tree</font>]</small></td>\n";
                        }
                        $data .= "</tr>\n";
                }
                $data .= "</table>\n";
                undef @@occurances;
                send_data($client, $data);
        } elsif ($type eq "simple") {
                my $trans = SNMP::translateObj($request);
                my ($oid, $mib);
                $oid = $request;

                if (!defined($trans)) {
                        send_data($client, "404");
                        return;
                }
                if ($numeric) {
                        $mib = $SNMP::MIB{$request};
                } else {
                        $mib = $SNMP::MIB{$trans};
                }

                my $type   = $$mib{'type'};
                my $syntax = $$mib{'syntax'};
                if ($type eq "OBJECTID") {
                        $type = "OBJECT ID";
                }
                if ($type eq "INTEGER" || $type eq "INTEGER32") {
                        $type = "Integer";
                } elsif ($type eq "OCTETSTR") {
                        $type = "OCTET STRING";
                } elsif ($type eq "NETADDR") {
                        $type = "NetAddress";
                } elsif ($type eq "IPADDR") {
                        $type = "IpAddress";
                } elsif ($type eq "COUNTER") {
                        $type = "Counter";
                } elsif ($type eq "GAUGE") {
                        $type = "Gauge";
                } elsif ($type eq "TICKS") {
                        $type = "TimeTicks";
                } elsif ($type eq "OPAQUE") {
                        $type = "Opaque";
                } elsif ($type eq "NULL") {
                        $type = "Null";
                } elsif ($type eq "BITSTRING" || $type eq "BITS") {
                        $type = "BitString";
                } elsif ($type eq "COUNTER64") {
                        $type = "Counter64";
                } elsif ($type eq "NSAPADDRESS") {
                        $type = "NsapAddress";
                } elsif (  $type eq "UINTEGER"
                        || $type eq "UINTEGER32"
                        || $type eq "UNSIGNED32")
                {
                        $type = "UInteger";
                } elsif ($type eq "NOTIF" || $type eq "TRAP") {
                        $type = "Trap";
                }

                if ($type eq "") {
                        $type = $syntax;
                }

                $data =
                      "<PRE>" . $oid . " = " . $trans . " (" . $type
                    . ")</pre>\n";
                send_data($client, $data);
        } elsif ($type eq "detail") {
                my $trans = SNMP::translateObj($request);
                if (!defined($trans)) {
                        send_data($client, "404");
                        return;
                }

                my $mib;
                if ($numeric) {
                        $mib = $SNMP::MIB{$request};
                } else {
                        $mib = $SNMP::MIB{$trans};
                }
                my $modules  = $$mib{'moduleID'};
                my $type     = $$mib{'type'};
                my $access   = $$mib{'access'};
                my $children = $$mib{'children'};
                my $status   = $$mib{'status'};
                my $syntax   = $$mib{'syntax'};
                my $descr    = $$mib{'description'};
                my $label    = $$mib{'label'};
                my $tc       = $$mib{'textualConvention'};
                my $subID    = $$mib{'subID'};
                my $enums    = $$mib{'enums'};
                my $ranges   = $$mib{'ranges'};
                my $hint     = $$mib{'hint'};
                my $indexes  = $$mib{'indexes'};
                my $varbinds = $$mib{'varbinds'};

                if ($access eq "Create") {
                        $access = "read-create";
                } elsif ($access eq "NoAccess") {
                        $access = "not-accessible";
                } elsif ($access eq "ReadOnly") {
                        $access = "read-only";
                } elsif ($access eq "ReadWrite") {
                        $access = "read-write";
                } elsif ($access eq "Notify") {
                        $access = "notify";
                }

                if ($type eq "OBJECTID") {
                        $type = "OBJECT ID";
                }
                if ($type eq "INTEGER" || $type eq "INTEGER32") {
                        $type = "Integer";
                } elsif ($type eq "OCTETSTR") {
                        $type = "OCTET STRING";
                } elsif ($type eq "NETADDR") {
                        $type = "NetAddress";
                } elsif ($type eq "IPADDR") {
                        $type = "IpAddress";
                } elsif ($type eq "COUNTER") {
                        $type = "Counter";
                } elsif ($type eq "GAUGE") {
                        $type = "Gauge";
                } elsif ($type eq "TICKS") {
                        $type = "TimeTicks";
                } elsif ($type eq "OPAQUE") {
                        $type = "Opaque";
                } elsif ($type eq "NULL") {
                        $type = "Null";
                } elsif ($type eq "BITSTRING" || $type eq "BITS") {
                        $type = "BitString";
                } elsif ($type eq "COUNTER64") {
                        $type = "Counter64";
                } elsif ($type eq "NSAPADDRESS") {
                        $type = "NsapAddress";
                } elsif (  $type eq "UINTEGER"
                        || $type eq "UINTEGER32"
                        || $type eq "UNSIGNED32")
                {
                        $type = "UInteger";
                } elsif ($type eq "NOTIF" || $type eq "TRAP") {
                        $type = "Trap";
                }

                if ($type eq "") {
                        $type = $syntax;
                }

                #	$descr =~ s/\s+/ /g;
                if ($descr) {
                        $descr = "\"" . $descr . "\"";
                }

                my $oid;
                $data = "<PRE>\n";
                if ($numeric) {
                        $data .= $request;
                        $oid = $request;

                } else {
                        $data .= $trans;
                        $oid = $trans;
                }
                $oid =~ s/^\.//;
                $data .= "\n";
                $data .= $label . " OBJECT-TYPE\n";
                my $module;
                $data .= "\t-- FROM\t";

                if (ref($modules) eq "ARRAY") {
                        foreach $module (@@{$modules}) {
                                $data .= $module . ", ";
                        }
                } else {
                        $data .= $modules;
                }
                $data =~ s/, $//;
                $data .= "\n";

                if ($tc ne "") {
                        $data .= "\t-- TEXTUAL CONVENTION $tc\n";
                }
                if ($type ne "" && $type ne "Trap") {
                        if (defined $enums && scalar(keys %{$enums}) > 0) {
                                $data .= "\tSYNTAX\t\t" . $type . " { ";
                                my $cpos = 0;
                                my $cmax = 1000000 - 16;
                                my $enum;

                                foreach $enum (
                                        sort { $enums->{$a} <=> $enums->{$b} }
                                        keys %{$enums}
                                    )
                                {
                                        my $buf;
                                        my $bufw;
                                        $buf = sprintf "%s(%d)", $enum,
                                            $enums->{$enum};
                                        $cpos += ($bufw = length($buf) + 2);

                                        if ($cpos >= $cmax) {
                                                $data .= "\n";
                                                $cpos = $bufw;
                                        }
                                        $data .= $buf;

                                        if ($enums != $$mib{'enums'}) {
                                                $data .= ", ";
                                        }
                                }
                                $data =~ s/, $//;
                                $data .= " }\n";
                        } else {
                                my $range;

                                if (defined $ranges && (scalar(@@{$ranges}) > 0))
                                {
                                        $data .= "\tSYNTAX\t\t$type (";
                                        foreach $range (@@{$ranges}) {
                                                if ($range->{'low'} ==
                                                        $range->{'high'})
                                                {
                                                        $data .=
                                                            $range->{'low'};
                                                } else {
                                                        $data .=
                                                              $range->{'low'}
                                                            . ".."
                                                            . $range->{'high'};
                                                }
                                                $data .= "|";
                                        }
                                        $data =~ s/\|$//;
                                        $data .= ")";
                                        $data .= "\n";
                                } else {
                                        $data .= "\tSYNTAX\t\t" . $type . "\n";
                                }
                        }

                        if ($hint ne "") {
                                $data .= "\tDISPLAY-HINT\t\"" . $hint . "\"\n";
                        }
                        $data .= "\tMAX-ACCESS\t" . $access . "\n";
                        $data .= "\tSTATUS\t\t" . $status . "\n";
                }

                if ($type eq "Trap") {
                        $data .= "\tTRAP\n";
                }
                if (defined $indexes && scalar(@@{$indexes}) > 0) {
                        $data .= "\tINDEXES\t\t" . "{ ";
                        my $cpos = 0;
                        my $cmax = 1000000 - 16;
                        my $index;

                        foreach $index (@@{$indexes}) {
                                my $buf;
                                my $bufw;
                                $buf = sprintf
                                    "<A HREF=\"$ME?oid=%s&xOps=detail\">%s</A>",
                                    $index, $index;
                                $cpos += ($bufw = length($buf) + 2);

                                if ($cpos >= $cmax) {
                                        $data .= "\n";
                                        $cpos = $bufw;
                                }
                                $data .= $buf;

                                if ($indexes != $$mib{'indexes'}) {
                                        $data .= ", ";
                                }
                        }
                        $data =~ s/, $//;
                        $data .= " }\n";
                }

                if ($varbinds && scalar(@@{$varbinds}) > 0) {
                        $data .= "\tVARBINDS\t" . "{ ";
                        my $cpos = 0;
                        my $cmax = 1000000 - 16;
                        my $varbind;

                        foreach $varbind (@@{$varbinds}) {
                                my $buf;
                                my $bufw;
                                $buf = sprintf
                                    "<A HREF=\"$ME?oid=%s&xOps=detail\">%s</A>",
                                    $varbind, $varbind;
                                $cpos += ($bufw = length($buf) + 2);

                                if ($cpos >= $cmax) {
                                        $data .= "\n";
                                        $cpos = $bufw;
                                }
                                $data .= $buf;

                                if ($varbinds != $$mib{'varbinds'}) {
                                        $data .= ", ";
                                }
                        }
                        $data =~ s/, $//;
                        $data .= " }\n";
                }

                if ($descr) {
                        $data .= "\tDESCRIPTION    " . $descr . "\n";
                }
                $data .= "::= { ";
                my @@parts = split(/\./, $oid);
                my ($savepart);
                $SNMP::use_long_names = 0;
                my $i;

                for ($i = 0 ; $i < $#parts ; $i++) {
                        $savepart .= ".$parts[$i]";
                        my $tmp = SNMP::translateObj($savepart);
                        $tmp =~ s/^\.//;
                        $data .= $tmp . "($parts[$i]) ";
                }
                $data .= "$parts[$i] ";
                $data .= "}\n";
                $data .= "</pre>\n";
                send_data($client, $data);
        } elsif ($type eq "tree") {
                my $trans;
                $data = "<PRE>\n";

                if ($numeric) {
                        my $mib  = $SNMP::MIB{$request};
                        my $foid = "";
                        foreach my $soid (
                                split(/\./, ($mib->{'parent'})->{'objectID'}))
                        {
                                next unless $soid;
                                $foid .= "." . $soid;
                                $data .=
                                    ".<A HREF=\"$ME?oid=$foid&xOps=tree\" TITLE=\"$foid\" ALT=\"$foid\"><FONT COLOR=\"green\">$soid</font></a>";
                        }
                        $data .= "\n";
                        eval {
                                alarm($TIMEOUT_SECS);
                                $data .= walkMIB($client, $request, $request);
                                alarm(0);
                        };

                        if ($@@) {
                                if ($@@ =~ /timeout/) {
                                        send_data($client, "502");
                                        return;
                                } else {
                                        alarm(0);
                                        send_data($client, "500");
                                        return;
                                }
                        }
                } else {
                        $trans = SNMP::translateObj($request);
                        my $mib  = $SNMP::MIB{$trans};
                        my $foid = "";
                        foreach my $soid (
                                split(/\./, ($mib->{'parent'})->{'objectID'}))
                        {
                                next unless $soid;
                                $foid .= "." . $soid;
                                $data .=
                                    ".<A HREF=\"$ME?oid=$foid&xOps=tree\" TITLE=\"$foid\" ALT=\"$foid\"><FONT COLOR=\"green\">$soid</font></a>";
                        }
                        $data .= "\n";
                        eval {
                                alarm($TIMEOUT_SECS);
                                $data .= walkMIB($client, $request, $trans);
                                alarm(0);
                        };

                        if ($@@) {
                                if ($@@ =~ /timeout/) {
                                        send_data($client, "502");
                                        return;
                                } else {
                                        alarm(0);
                                        send_data($client, "500");
                                        return;
                                }
                        }
                }
                $data .= "</pre>\n";
                send_data($client, $data);
        } else {
                send_data($client, "500");
        }
        undef $type;
        undef $request;
        undef $data;
        undef $tree_buffer;
}

sub find_occurances {
        my ($pattern, $search_descr, $mib, $patterns) = @@_;
        my ($tp, $tmp, $condition);

        foreach $tp (@@{$mib->{'children'}}) {
                $condition = 0;
                if ($search_descr && length($tp->{'description'})) {
                        $condition = 1
                            if (   $tp->{'label'} =~ /$pattern/i
                                || $tp->{'description'} =~ /$pattern/i);
                } else {
                        $condition = 1 if ($tp->{'label'} =~ /$pattern/i);
                }

                if ($condition) {
                        if (scalar(@@{$tp->{'children'}})) {
                                $tmp = $tp->{'label'} . "|" . 1;
                        } else {
                                $tmp = $tp->{'label'} . "|" . 0;
                        }

                        push @@{$patterns}, $tmp;
                }
        }
        foreach $tp (@@{$mib->{'children'}}) {
                if (scalar $tp->{'children'}) {
                        find_occurances($pattern, $search_descr, $tp,
                                $patterns);
                }
        }
}

sub walkMIB {
        my ($client, $pattern, $oid) = @@_;
        if (!defined($oid)) {
                send_data($client, "404");
                return undef;
        }
        my $data;
        $leave_indent[0] = ' ';
        $leave_was_simple = 0;
        $data = print_mib_leaves($oid, 1000000);

        return $data;
}

sub print_mib_leaves {
        my ($oid, $level) = @@_;
        my $nextOid;
        my ($cp, $child);
        my $test_count = 0;
        my $size       = 0;
        my $ip         = scalar(@@leave_indent) - 1;
        my $last_ipch  = $leave_indent[$ip];

        $leave_indent[$ip] = '+';
        my $mib = $SNMP::MIB{$oid};
        $cp = $mib->{'children'};
        foreach $child (@@{$cp}) {
                $test_count++;
        }
        undef $cp;
        undef $child;

        my $st = SNMP::translateObj($$mib{'label'});
        my $sm = $SNMP::MIB{$st};
        my $sd = $$sm{'description'};
        $sd =~ s/\s+/ /g;

        if ($$mib{'type'} eq "") {
                if ($test_count) {
                        $tree_buffer .=
                            join("", @@leave_indent)
                            . "--<A HREF=\"$ME?oid=$$mib{'label'}&xOps=tree\"><FONT COLOR=\"green\">$$mib{'label'}</FONT></A>($$mib{'subID'}) <SMALL><A HREF=\"$ME?oid=$$mib{'label'}&xOps=detail\" title=\"$sd\" alt=\"$sd\"><FONT COLOR=\"#DC00DC\">detail</FONT></A></SMALL>\n";
                } else {
                        $tree_buffer .=
                            join("", @@leave_indent)
                            . "--<A HREF=\"$ME?oid=$$mib{'label'}&xOps=detail\" title=\"$sd\" alt=\"$sd\"><FONT COLOR=\"#DC00DC\">$$mib{'label'}</FONT></A>($$mib{'subID'})\n";
                }

        } else {
                my ($acc, $typ);
                if ($$mib{'access'} eq "NoAccess") {
                        $acc = "----";
                } elsif ($$mib{'access'} eq "ReadOnly") {
                        $acc = "-R--";
                } elsif ($$mib{'access'} eq "ReadWrite") {
                        $acc = "-RW-";
                } elsif ($$mib{'access'} eq "Notify") {
                        $acc = "---N";
                } elsif ($$mib{'access'} eq "Create") {
                        $acc = "CR--";
                } else {
                        $acc = "    ";
                }

                if ($$mib{'type'} eq "OBJECTID") {
                        $typ = "ObjID    ";
                } elsif ($$mib{'type'} eq "OCTETSTR") {
                        $size = 1;
                        $typ  = "String   ";
                } elsif (  $$mib{'type'} eq "INTEGER"
                        || $$mib{'type'} eq "INTEGER32")
                {

                        if (scalar(keys %{$mib->{'enums'}}) > 0) {
                                $typ = "EnumVal  ";
                        } else {
                                $typ = "Integer  ";
                        }
                } elsif ($$mib{'type'} eq "NETADDR") {
                        $typ = "NetAddr  ";
                } elsif ($$mib{'type'} eq "IPADDR") {
                        $typ = "IpAddr   ";
                } elsif ($$mib{'type'} eq "COUNTER") {
                        $typ = "Counter  ";
                } elsif ($$mib{'type'} eq "GAUGE") {
                        $typ = "Gauge    ";
                } elsif ($$mib{'type'} eq "TICKS") {
                        $typ = "Timeticks";
                } elsif ($$mib{'type'} eq "OPAQUE") {
                        $size = 1;
                        $typ  = "Opaque   ";
                } elsif ($$mib{'type'} eq "NULL") {
                        $typ = "Null     ";
                } elsif ($$mib{'type'} eq "COUNTER64") {
                        $typ = "Counter64";
                } elsif (  $$mib{'type'} eq "BITSTRING"
                        || $$mib{'type'} eq "BITS")
                {
                        $typ = "BitString";
                } elsif ($$mib{'type'} eq "NSAPADDRESS") {
                        $typ = "NsapAddr ";
                } elsif (  $$mib{'type'} eq "UINTEGER"
                        || $$mib{'type'} eq "UINTEGER32"
                        || $$mib{'type'} eq "UNSIGNED32")
                {
                        $typ = "UInteger ";
                } elsif ($$mib{'type'} eq "NOTIF" || $$mib{'type'} eq "TRAP") {
                        $typ = "<B>Trap</B>";
                } else {
                        $typ = "         ";
                }

                my $st = SNMP::translateObj($$mib{'label'});
                my $sm = $SNMP::MIB{$st};
                my $sd = $$sm{'description'};
                $sd =~ s/\s+/ /g;

                if ($test_count) {
                        $tree_buffer .=
                            join("", @@leave_indent)
                            . "-- $acc $typ <A HREF=\"$ME?oid=$$mib{'label'}&xOps=tree\"><FONT COLOR=\"green\">$$mib{'label'}</FONT></A>($$mib{'subID'}) <SMALL><A HREF=\"$ME?oid=$$mib{'label'}&xOps=detail\" title=\"$sd\" alt=\"$sd\"><FONT COLOR=\"#DC00DC\">detail</FONT></A></SMALL>\n";
                } else {
                        $tree_buffer .=
                            join("", @@leave_indent)
                            . "-- $acc $typ <A HREF=\"$ME?oid=$$mib{'label'}&xOps=detail\" title=\"$sd\" alt=\"$sd\"><FONT COLOR=\"#DC00DC\">$$mib{'label'}</FONT></A>($$mib{'subID'})\n";
                }

                $leave_indent[$ip] = $last_ipch;
                if ($$mib{'textualConvention'} ne "") {
                        $tree_buffer .=
                            join("", @@leave_indent)
                            . "        Textual Convention: $$mib{'textualConvention'}\n";
                }

                if (scalar(keys %{$mib->{'enums'}}) > 0) {
                        my $ep   = $$mib{'enums'};
                        my $cpos = 0;
                        my $cmax = $level - scalar(@@leave_indent) - 16;
                        $tree_buffer .=
                            join("", @@leave_indent) . "        Values: ";
                        my $key;

                        foreach $key (
                                sort { $ep->{$a} <=> $ep->{$b} }
                                keys %{$ep}
                            )
                        {
                                my $buf;
                                my $bufw;
                                $buf = sprintf "%s(%d)", $key, $ep->{$key};
                                $cpos += ($bufw = length($buf) + 2);
                                if ($cpos >= $cmax) {
                                        $tree_buffer .= "\n"
                                            . join("", @@leave_indent)
                                            . "                ";
                                        $cpos = $bufw;
                                }
                                $tree_buffer .= $buf;

                                if ($ep != $$mib{'enums'}) {
                                        $tree_buffer .= ", ";
                                }

                        }
                        $tree_buffer =~ s/, $//;
                        $tree_buffer .= "\n";
                }
        }

        if ($mib->{'ranges'} && scalar(@@{$mib->{'ranges'}}) > 0) {
                my $range;
                if ($size == 1) {
                        $tree_buffer .=
                            join("", @@leave_indent) . "        Size: ";
                } else {
                        $tree_buffer .=
                            join("", @@leave_indent) . "        Range: ";
                }

                foreach $range (@@{$mib->{'ranges'}}) {
                        my $key;
                        if ($range->{'low'} == $range->{'high'}) {
                                $tree_buffer .= $range->{'low'};
                        } else {
                                $tree_buffer .=
                                    "$range->{'low'}..$range->{'high'}";
                        }
                        $tree_buffer .= "|";
                }
                $tree_buffer =~ s/\|$//;
                $tree_buffer .= "\n";
        }
        $leave_indent[$ip] = $last_ipch;
        push @@leave_indent, ' ';
        push @@leave_indent, ' ';
        push @@leave_indent, '|';
        $leave_was_simple = ($$mib{'type'} ne "");

        my ($count, $i);
        $count = 0;

        my $children = $$mib{'children'};
        foreach $nextOid (@@{$children}) {
                $count++;
        }
        if ($count) {
                $i = 0;
                my $np;

                foreach $np (sort { $a->{'subID'} <=> $b->{'subID'} }
                        @@{$children})
                {
                        if (
                                (
                                           $leave_was_simple == 0
                                        || $leave_was_simple eq ""
                                )
                                || ($np->{'type'} eq "")
                            )
                        {
                                $tree_buffer .= join("", @@leave_indent) . "\n";
                        }

                        if ($i == $count) {
                                my $j;
                                for ($j = 0 ; $j < 3 ; $j++) {
                                        push @@leave_indent, " ";
                                }
                        }

                        print_mib_leaves($np->{'objectID'}, $level);
                        $i++;

                }
                $leave_was_simple = 0;
        }
        my $k;
        for ($k = 0 ; $k < 3 ; $k++) {
                pop @@leave_indent;
        }
        return $tree_buffer;
}

sub send_data {
        my ($client, $data) = @@_;
        my ($old_fh);

        $old_fh = select $client;
        $|      = 1;
        $data =~ s/\n/<br>/g;
        print $client $data . "\n";
        select $old_fh;
        $| = 1;
}

sub get_data {
        my ($client) = $_[0];
        my ($data);

        $data = <$client>;
        $data =~ s/\W+$//g;
        $data =~ s/<br>/\n/g;
        return $data;
}

@


1.12
log
@Make the link color green for each of the parent OIDs.
@
text
@d27 1
a27 1
# $Id: snmptransd.pl,v 1.11 2003/09/30 21:41:13 jmarcus Exp $
d97 1
a97 1
$rcsid = '$Id: snmptransd.pl,v 1.11 2003/09/30 21:41:13 jmarcus Exp $';
d341 2
a342 1
                my $type = $$mib{'type'};
d364 1
a364 1
                } elsif ($type eq "BITSTRING") {
d379 4
d449 1
a449 1
                } elsif ($type eq "BITSTRING") {
d464 4
d845 3
a847 1
                } elsif ($$mib{'type'} eq "BITSTRING") {
@


1.11
log
@Allow one to go up random levels in the tree view.
@
text
@d27 1
a27 1
# $Id: snmptransd.pl,v 1.10 2003/07/17 06:31:06 jmarcus Exp $
d97 1
a97 1
$rcsid = '$Id: snmptransd.pl,v 1.10 2003/07/17 06:31:06 jmarcus Exp $';
d649 1
a649 1
                                    ".<A HREF=\"$ME?oid=$foid&xOps=tree\" TITLE=\"$foid\" ALT=\"$foid\">$soid</a>";
d678 1
a678 1
                                    ".<A HREF=\"$ME?oid=$foid&xOps=tree\" TITLE=\"$foid\" ALT=\"$foid\">$soid</a>";
@


1.10
log
@Add support for popping up a title box with the leaf descriptions in the
tree view.
@
text
@d27 1
a27 1
# $Id: snmptransd.pl,v 1.9 2001/08/22 13:12:45 jmarcus Exp $
d97 1
a97 1
$rcsid = '$Id: snmptransd.pl,v 1.9 2001/08/22 13:12:45 jmarcus Exp $';
d311 1
a311 1
                        my ($value, $isbranch) = split (/\|/, $occurance);
d379 1
a379 1
                    "<PRE>" . $oid . " = " . $trans . " (" . $type
d536 2
a537 1
                                                        $data .= $range->{'low'}
d621 1
a621 1
                my @@parts = split (/\./, $oid);
d641 11
a651 2
                        my $mib = $SNMP::MIB{$request};
                        $data .= ($mib->{'parent'})->{'objectID'} . "\n";
d670 11
a680 2
                        my $mib = $SNMP::MIB{$trans};
                        $data .= ($mib->{'parent'})->{'objectID'} . "\n";
d781 1
a781 1
                            join ("", @@leave_indent)
d785 1
a785 1
                            join ("", @@leave_indent)
d858 1
a858 1
                            join ("", @@leave_indent)
d862 1
a862 1
                            join ("", @@leave_indent)
d869 1
a869 1
                            join ("", @@leave_indent)
d878 1
a878 1
                            join ("", @@leave_indent) . "        Values: ";
d881 4
a884 2
                        foreach $key (sort { $ep->{$a} <=> $ep->{$b} }
                                keys %{$ep})
d892 1
a892 1
                                            . join ("", @@leave_indent)
d912 1
a912 1
                            join ("", @@leave_indent) . "        Size: ";
d915 1
a915 1
                            join ("", @@leave_indent) . "        Range: ";
d959 1
a959 1
                                $tree_buffer .= join ("", @@leave_indent) . "\n";
@


1.9
log
@Fix a bug where data wouldn't be printed out in tree format if a
numeric OID was entered.
@
text
@d27 1
a27 1
# $Id: snmptransd.pl,v 1.8 2001/08/16 05:59:23 jmarcus Exp $
d31 1
a31 1
    $ENV{'PATH'} = '/bin:/usr/bin';
d33 2
a34 2
    # Set LD_LIBRARY_PATH to the location of the net-snmp (ucd-snmp) libraries.
    #$ENV{'LD_LIBRARY_PATH'} = '';
d36 38
a73 38
    # Zero out all previous environment variables.
    $ENV{'MIBS'}    = '';
    $ENV{'MIBDIRS'} = '';

    $MIBS = 'ALL';

    # Set this directory to the location where your MIBs are stored.
    $MIBDIRS = '/usr/local/share/snmp/mibs';

    # This is the name of the client CGI piece.  It should be a relative path
    # from the HTTP root.
    $ME = '/cgi-bin/snmptransc.pl';

    # Specify the location of the pidfile.  This is where the process id of the 
    # server parent will be written to.  This is usually /var/run.
    $PIDFILE = '/var/run/snmptransd.pid';

    # Specify the local port for the server to bind to.  This is 3333 
    # by default.
    $LOCAL_PORT = 3333;

    # Specify the number of seconds to wait before throwing a timeout exception.
    # This helps avoid denial of service attacks if the MIB tree is large.  The
    # default is 5 minutes.
    $TIMEOUT_SECS = 300;

    # Enable CHAP-like security for connecting to the server process.  This is 
    # disable by default.  Set this to the name of the password file to 
    # enable security.
    $SECURITY = "";

    # Enable global MIB module replacement.  This is a parsing option that tells
    # net-snmp to replace older loaded MIB modules with newer ones.  This can 
    # overwrite older, less-descriptive, MIB objects with newer, more 
    # descriptive ones (e.g. ifOperStatus from RFC1213 and IF).  
    # WARNING: this can cause an inconsistent MIB hierarchy.  Use this option 
    # with care.
    $REPLACE = 0;
d78 1
a78 1
  qw($rcsid $SECURITY $PIDFILE $TIMEOUT_SECS $LOCAL_PORT $REPLACE $server $MAXLEN $PREFORK $MAX_CLIENTS_PER_CHILD %children $children $ME $MIBS $MIBDIRS $HTTPMIBS %contents @@leave_indent $leave_was_simple $tree_buffer $last_ip);
d92 4
a95 4
sub LOCK_SH {1}
sub LOCK_EX {2}
sub LOCK_NB {4}
sub LOCK_UN {8}
d97 1
a97 1
$rcsid = '$Id: snmptransd.pl,v 1.8 2001/08/16 05:59:23 jmarcus Exp $';
d100 16
a115 15
    LocalPort => $LOCAL_PORT,
    Type      => SOCK_STREAM,
    Proto     => 'tcp',
    Reuse     => 1,
    Listen    => 10
) or die "Error creating socket: $@@\n";

if ( -f $PIDFILE ) {
    unless ( open( PID, $PIDFILE ) ) {
        die "Unable to open $PIDFILE for reading: $!\n";
    }
    my $pid = <PID>;
    print "Server already running as process $pid.\n";
    close(PID);
    exit(1);
d118 2
a119 2
unless ( open( PID, ">" . $PIDFILE ) ) {
    die "Unable to open $PIDFILE for writing: $!\n";
d121 1
a121 1
flock( PID, LOCK_EX );
d129 2
a130 2
$MAXLEN  = 1024;
$PREFORK = 5;
d132 2
a133 2
%children = ();
$children = 0;
d138 4
a141 4
    $SIG{CHLD} = \&REAPER;
    my $pid = wait;
    $children--;
    delete $children{$pid};
d145 3
a147 3
    local ( $SIG{CHLD} ) = 'IGNORE';
    kill 'INT' => keys %children;
    CLEANUP();
d151 2
a152 2
    unlink $PIDFILE;
    exit(0);
d155 2
a156 2
for ( 1 .. $PREFORK ) {
    make_new_child();
d165 1
a165 34
    sleep;
    my $i;
    for ( $i = $children ; $i < $PREFORK ; $i++ ) {
        make_new_child();
    }
}

sub make_new_child {
    my $pid;
    my $sigset;

    $sigset = POSIX::SigSet->new(SIGINT);
    sigprocmask( SIG_BLOCK, $sigset )
      or die "Can't block SIGINT for fork: $!\n";

    die "fork: $!" unless defined( $pid = fork );

    if ($pid) {
        sigprocmask( SIG_UNBLOCK, $sigset )
          or die "Can't unblock SIGINT for fork: $!\n";
        $children{$pid} = 1;
        $children++;
        return;
    }
    else {
        $SIG{INT} = 'DEFAULT';

        # This signal handler controls what to do if the snmptrans operation 
        # runs for too long.  We will catch this timeout, and return an error.
        $SIG{ALRM} = sub { die "timeout" };

        sigprocmask( SIG_UNBLOCK, $sigset )
          or die "Can't unblock SIGINT for fork: $!\n";

d167 2
a168 4
        for ( $i = 0 ; $i < $MAX_CLIENTS_PER_CHILD ; $i++ ) {
            my $client = $server->accept() or last;
            snmptrans($client);
            $client->close() if ($client);
a169 2
    }
    exit;
d172 3
a174 4
sub snmptrans {
    my ($client) = $_[0];
    my ( $bg, $replace, $type, $size, $request, $numeric );
    my $data;
d176 11
a186 83
    # XXX Make all the client/server code a little clearer.  By this, I should
    # have codes that trigger options being set, and codes that indicate data.
    # Right now, things are too messy.

    if ( $SECURITY ne "" ) {
        use Digest::MD5 qw(md5_hex);
        unless ( open( PW, $SECURITY ) ) {
            die "Cannot open password file $SECURITY: $!\n";
        }

        my $pw = <PW>;

        close(PW);

        chomp $pw;

        $type = get_data($client);
        if ( $type eq "digest" ) {
            send_data( $client, "403" );
        }
        else {
            send_data( $client, "501" );
            return;
        }
        my $digest = get_data($client);

        if ( $digest eq md5_hex($pw) ) {
            send_data( $client, "200" );
        }
        else {
            send_data( $client, "403" );
            return;
        }
    }

    $type = get_data($client);
    send_data( $client, "200" );
    $bg = get_data($client);
    send_data( $client, "200" );
    if ( $bg eq "1" ) {
        $SNMP::best_guess = 1;
    }
    $replace = get_data($client);
    send_data( $client, "200" );
    $request = get_data($client);

    if ( $replace eq "1" ) {
        $SNMP::replace_newer = 1;
    }

    if ( $request =~ /^(\d+\.)+\d+$/ ) {
        $request = "." . $request;
        $numeric = 1;
    }
    elsif ( $request =~ /^\.(\d+\.)+\d+$/ ) {
        $numeric = 1;
    }

    if ( $type eq "pattern" ) {
        send_data( $client, "200" );
        my $search_descr = get_data($client);
        if ( !( eval { 'snmp' =~ /$request/i, 1 } ) ) {
            send_data( $client, "501" );
            return;
        }

        if ( $search_descr eq "1" ) {
            $search_descr = 1;
        }
        else {
            $search_descr = 0;
        }
        my $mib        = $SNMP::MIB{'.1'};    # Start from the root.
        my @@occurances = ();
        eval {
            alarm($TIMEOUT_SECS);
            find_occurances( $request, $search_descr, $mib, \@@occurances );
            alarm(0);
        };

        if ($@@) {
            if ( $@@ =~ /timeout/ ) {
                send_data( $client, "502" );
d188 2
a189 8
            }
            else {
                alarm(0);
                send_data( $client, "500" );
                return;
            }
        }
        my ($occurance);
d191 3
a193 6
        if ( !( scalar @@occurances ) ) {
            send_data( $client, "404" );
            return;
        }
        $data = "<H3>Found " . scalar @@occurances . " match(es)</h3>\n";
        $data .= "<TABLE BORDER=\"0\">\n";
d195 2
a196 23
        foreach $occurance (@@occurances) {
            $data .= "<TR>\n";
            my ( $value, $isbranch ) = split ( /\|/, $occurance );
            if ($isbranch) {
                $data .= "<TD>$value</td>\n";
                $data .=
"<TD><SMALL>[<A HREF=\"$ME?oid=$value&xOps=detail\">detail</a>] | [<A HREF=\"$ME?oid=$value&xOps=tree\">tree</a>]</small></td>\n";
            }
            else {
                $data .= "<TD>$value</td>\n";
                $data .=
"<TD><SMALL>[<A HREF=\"$ME?oid=$value&xOps=detail\">detail</a>] | [<FONT COLOR=\"lightgrey\">tree</font>]</small></td>\n";
            }
            $data .= "</tr>\n";
        }
        $data .= "</table>\n";
        undef @@occurances;
        send_data( $client, $data );
    }
    elsif ( $type eq "simple" ) {
        my $trans = SNMP::translateObj($request);
        my ( $oid, $mib );
        $oid = $request;
d198 6
a203 9
        if ( !defined($trans) ) {
            send_data( $client, "404" );
            return;
        }
        if ($numeric) {
            $mib = $SNMP::MIB{$request};
        }
        else {
            $mib = $SNMP::MIB{$trans};
d205 2
d208 4
a211 48
        my $type = $$mib{'type'};
        if ( $type eq "OBJECTID" ) {
            $type = "OBJECT ID";
        }
        if ( $type eq "INTEGER" || $type eq "INTEGER32" ) {
            $type = "Integer";
        }
        elsif ( $type eq "OCTETSTR" ) {
            $type = "OCTET STRING";
        }
        elsif ( $type eq "NETADDR" ) {
            $type = "NetAddress";
        }
        elsif ( $type eq "IPADDR" ) {
            $type = "IpAddress";
        }
        elsif ( $type eq "COUNTER" ) {
            $type = "Counter";
        }
        elsif ( $type eq "GAUGE" ) {
            $type = "Gauge";
        }
        elsif ( $type eq "TICKS" ) {
            $type = "TimeTicks";
        }
        elsif ( $type eq "OPAQUE" ) {
            $type = "Opaque";
        }
        elsif ( $type eq "NULL" ) {
            $type = "Null";
        }
        elsif ( $type eq "BITSTRING" ) {
            $type = "BitString";
        }
        elsif ( $type eq "COUNTER64" ) {
            $type = "Counter64";
        }
        elsif ( $type eq "NSAPADDRESS" ) {
            $type = "NsapAddress";
        }
        elsif ( $type eq "UINTEGER" || $type eq "UINTEGER32"
          || $type eq "UNSIGNED32" )
        {
            $type = "UInteger";
        }
        elsif ( $type eq "NOTIF" || $type eq "TRAP" ) {
            $type = "Trap";
        }
d213 3
a215 9
        $data = "<PRE>" . $oid . " = " . $trans . " (" . $type . ")</pre>\n";
        send_data( $client, $data );
    }
    elsif ( $type eq "detail" ) {
        my $trans = SNMP::translateObj($request);
        if ( !defined($trans) ) {
            send_data( $client, "404" );
            return;
        }
d217 5
a221 22
        my $mib;
        if ($numeric) {
            $mib = $SNMP::MIB{$request};
        }
        else {
            $mib = $SNMP::MIB{$trans};
        }
        my $modules  = $$mib{'moduleID'};
        my $type     = $$mib{'type'};
        my $access   = $$mib{'access'};
        my $children = $$mib{'children'};
        my $status   = $$mib{'status'};
        my $syntax   = $$mib{'syntax'};
        my $descr    = $$mib{'description'};
        my $label    = $$mib{'label'};
        my $tc       = $$mib{'textualConvention'};
        my $subID    = $$mib{'subID'};
        my $enums    = $$mib{'enums'};
        my $ranges   = $$mib{'ranges'};
        my $hint     = $$mib{'hint'};
        my $indexes  = $$mib{'indexes'};
        my $varbinds = $$mib{'varbinds'};
d223 1
a223 15
        if ( $access eq "Create" ) {
            $access = "read-create";
        }
        elsif ( $access eq "NoAccess" ) {
            $access = "not-accessible";
        }
        elsif ( $access eq "ReadOnly" ) {
            $access = "read-only";
        }
        elsif ( $access eq "ReadWrite" ) {
            $access = "read-write";
        }
        elsif ( $access eq "Notify" ) {
            $access = "notify";
        }
d225 1
a225 47
        if ( $type eq "OBJECTID" ) {
            $type = "OBJECT ID";
        }
        if ( $type eq "INTEGER" || $type eq "INTEGER32" ) {
            $type = "Integer";
        }
        elsif ( $type eq "OCTETSTR" ) {
            $type = "OCTET STRING";
        }
        elsif ( $type eq "NETADDR" ) {
            $type = "NetAddress";
        }
        elsif ( $type eq "IPADDR" ) {
            $type = "IpAddress";
        }
        elsif ( $type eq "COUNTER" ) {
            $type = "Counter";
        }
        elsif ( $type eq "GAUGE" ) {
            $type = "Gauge";
        }
        elsif ( $type eq "TICKS" ) {
            $type = "TimeTicks";
        }
        elsif ( $type eq "OPAQUE" ) {
            $type = "Opaque";
        }
        elsif ( $type eq "NULL" ) {
            $type = "Null";
        }
        elsif ( $type eq "BITSTRING" ) {
            $type = "BitString";
        }
        elsif ( $type eq "COUNTER64" ) {
            $type = "Counter64";
        }
        elsif ( $type eq "NSAPADDRESS" ) {
            $type = "NsapAddress";
        }
        elsif ( $type eq "UINTEGER" || $type eq "UINTEGER32"
          || $type eq "UNSIGNED32" )
        {
            $type = "UInteger";
        }
        elsif ( $type eq "NOTIF" || $type eq "TRAP" ) {
            $type = "Trap";
        }
d227 1
a227 4
        #	$descr =~ s/\s+/ /g;
        if ($descr) {
            $descr = "\"" . $descr . "\"";
        }
d229 8
a236 5
        my $oid;
        $data = "<PRE>\n";
        if ($numeric) {
            $data .= $request;
            $oid = $request;
d238 6
a244 9
        else {
            $data .= $trans;
            $oid = $trans;
        }
        $oid =~ s/^\.//;
        $data .= "\n";
        $data .= $label . " OBJECT-TYPE\n";
        my $module;
        $data .= "\t-- FROM\t";
d246 55
a300 10
        if ( ref($modules) eq "ARRAY" ) {
            foreach $module ( @@{$modules} ) {
                $data .= $module . ", ";
            }
        }
        else {
            $data .= $modules;
        }
        $data =~ s/, $//;
        $data .= "\n";
d302 151
a452 12
        if ( $tc ne "" ) {
            $data .= "\t-- TEXTUAL CONVENTION $tc\n";
        }
        if ( $type ne "" && $type ne "Trap" ) {
            if ( defined $enums && scalar( keys %{$enums} ) > 0 ) {
                $data .= "\tSYNTAX\t\t" . $type . " { ";
                my $cpos = 0;
                my $cmax = 1000000 - 16;
                my $enum;

                foreach $enum ( sort { $enums->{$a} <=> $enums->{$b} }
                    keys %{$enums} )
d454 32
a485 14
                    my $buf;
                    my $bufw;
                    $buf = sprintf "%s(%d)", $enum, $enums->{$enum};
                    $cpos += ( $bufw = length($buf) + 2 );

                    if ( $cpos >= $cmax ) {
                        $data .= "\n";
                        $cpos = $bufw;
                    }
                    $data .= $buf;

                    if ( $enums != $$mib{'enums'} ) {
                        $data .= ", ";
                    }
d488 1
a488 4
                $data .= " }\n";
            }
            else {
                my $range;
d490 58
a547 5
                if ( defined $ranges && ( scalar( @@{$ranges} ) > 0 ) ) {
                    $data .= "\tSYNTAX\t\t$type (";
                    foreach $range ( @@{$ranges} ) {
                        if ( $range->{'low'} == $range->{'high'} ) {
                            $data .= $range->{'low'};
d549 3
a551 2
                        else {
                            $data .= $range->{'low'} . ".." . $range->{'high'};
d553 2
a554 5
                        $data .= "|";
                    }
                    $data =~ s/\|$//;
                    $data .= ")";
                    $data .= "\n";
d556 3
a558 2
                else {
                    $data .= "\tSYNTAX\t\t" . $type . "\n";
d560 26
a585 28
            }

            if ( $hint ne "" ) {
                $data .= "\tDISPLAY-HINT\t\"" . $hint . "\"\n";
            }
            $data .= "\tMAX-ACCESS\t" . $access . "\n";
            $data .= "\tSTATUS\t\t" . $status . "\n";
        }

        if ( $type eq "Trap" ) {
            $data .= "\tTRAP\n";
        }
        if ( defined $indexes && scalar( @@{$indexes} ) > 0 ) {
            $data .= "\tINDEXES\t\t" . "{ ";
            my $cpos = 0;
            my $cmax = 1000000 - 16;
            my $index;

            foreach $index ( @@{$indexes} ) {
                my $buf;
                my $bufw;
                $buf = sprintf "<A HREF=\"$ME?oid=%s&xOps=detail\">%s</A>",
                  $index, $index;
                $cpos += ( $bufw = length($buf) + 2 );

                if ( $cpos >= $cmax ) {
                    $data .= "\n";
                    $cpos = $bufw;
a586 1
                $data .= $buf;
d588 26
a613 2
                if ( $indexes != $$mib{'indexes'} ) {
                    $data .= ", ";
a614 10
            }
            $data =~ s/, $//;
            $data .= " }\n";
        }

        if ( $varbinds && scalar( @@{$varbinds} ) > 0 ) {
            $data .= "\tVARBINDS\t" . "{ ";
            my $cpos = 0;
            my $cmax = 1000000 - 16;
            my $varbind;
d616 2
a617 10
            foreach $varbind ( @@{$varbinds} ) {
                my $buf;
                my $bufw;
                $buf = sprintf "<A HREF=\"$ME?oid=%s&xOps=detail\">%s</A>",
                  $varbind, $varbind;
                $cpos += ( $bufw = length($buf) + 2 );

                if ( $cpos >= $cmax ) {
                    $data .= "\n";
                    $cpos = $bufw;
d619 59
a677 4
                $data .= $buf;

                if ( $varbinds != $$mib{'varbinds'} ) {
                    $data .= ", ";
d679 9
a687 82
            }
            $data =~ s/, $//;
            $data .= " }\n";
        }

        if ($descr) {
            $data .= "\tDESCRIPTION    " . $descr . "\n";
        }
        $data .= "::= { ";
        my @@parts = split ( /\./, $oid );
        my ($savepart);
        $SNMP::use_long_names = 0;
        my $i;

        for ( $i = 0 ; $i < $#parts ; $i++ ) {
            $savepart .= ".$parts[$i]";
            my $tmp = SNMP::translateObj($savepart);
            $tmp =~ s/^\.//;
            $data .= $tmp . "($parts[$i]) ";
        }
        $data .= "$parts[$i] ";
        $data .= "}\n";
        $data .= "</pre>\n";
        send_data( $client, $data );
    }
    elsif ( $type eq "tree" ) {
        my $trans;
        $data = "<PRE>\n";

        if ($numeric) {
            my $mib = $SNMP::MIB{$request};
            $data .= ( $mib->{'parent'} )->{'objectID'} . "\n";
            eval {
                alarm($TIMEOUT_SECS);
                $data .= walkMIB( $client, $request, $request );
                alarm(0);
            };

            if ($@@) {
                if ( $@@ =~ /timeout/ ) {
                    send_data( $client, "502" );
                    return;
                }
                else {
                    alarm(0);
                    send_data( $client, "500" );
                    return;
                }
            }
        }
        else {
            $trans = SNMP::translateObj($request);
            my $mib = $SNMP::MIB{$trans};
            $data .= ( $mib->{'parent'} )->{'objectID'} . "\n";
            eval {
                alarm($TIMEOUT_SECS);
                $data .= walkMIB( $client, $request, $trans );
                alarm(0);
            };

            if ($@@) {
                if ( $@@ =~ /timeout/ ) {
                    send_data( $client, "502" );
                    return;
                }
                else {
                    alarm(0);
                    send_data( $client, "500" );
                    return;
                }
            }
        }
        $data .= "</pre>\n";
        send_data( $client, $data );
    }
    else {
        send_data( $client, "500" );
    }
    undef $type;
    undef $request;
    undef $data;
    undef $tree_buffer;
d691 2
a692 2
    my ( $pattern, $search_descr, $mib, $patterns ) = @@_;
    my ( $tp, $tmp, $condition );
d694 25
a718 25
    foreach $tp ( @@{ $mib->{'children'} } ) {
        $condition = 0;
        if ( $search_descr && length( $tp->{'description'} ) ) {
            $condition = 1
              if ( $tp->{'label'} =~ /$pattern/i
              || $tp->{'description'} =~ /$pattern/i );
        }
        else {
            $condition = 1 if ( $tp->{'label'} =~ /$pattern/i );
        }

        if ($condition) {
            if ( scalar( @@{ $tp->{'children'} } ) ) {
                $tmp = $tp->{'label'} . "|" . 1;
            }
            else {
                $tmp = $tp->{'label'} . "|" . 0;
            }

            push @@{$patterns}, $tmp;
        }
    }
    foreach $tp ( @@{ $mib->{'children'} } ) {
        if ( scalar $tp->{'children'} ) {
            find_occurances( $pattern, $search_descr, $tp, $patterns );
a719 1
    }
d723 9
a731 9
    my ( $client, $pattern, $oid ) = @@_;
    if ( !defined($oid) ) {
        send_data( $client, "404" );
        return undef;
    }
    my $data;
    $leave_indent[0] = ' ';
    $leave_was_simple = 0;
    $data = print_mib_leaves( $oid, 1000000 );
d733 1
a733 1
    return $data;
d737 57
a793 7
    my ( $oid, $level ) = @@_;
    my $nextOid;
    my ( $cp, $child );
    my $test_count = 0;
    my $size       = 0;
    my $ip         = scalar(@@leave_indent) - 1;
    my $last_ipch  = $leave_indent[$ip];
d795 85
a879 8
    $leave_indent[$ip] = '+';
    my $mib = $SNMP::MIB{$oid};
    $cp = $mib->{'children'};
    foreach $child ( @@{$cp} ) {
        $test_count++;
    }
    undef $cp;
    undef $child;
d881 4
a884 10
    if ( $$mib{'type'} eq "" ) {
        if ($test_count) {
            $tree_buffer .=
              join ( "", @@leave_indent )
              . "--<A HREF=\"$ME?oid=$$mib{'label'}&xOps=tree\"><FONT COLOR=\"green\">$$mib{'label'}</FONT></A>($$mib{'subID'}) <SMALL><A HREF=\"$ME?oid=$$mib{'label'}&xOps=detail\"><FONT COLOR=\"#DC00DC\">detail</FONT></A></SMALL>\n";
        }
        else {
            $tree_buffer .=
              join ( "", @@leave_indent )
              . "--<A HREF=\"$ME?oid=$$mib{'label'}&xOps=detail\"><FONT COLOR=\"#DC00DC\">$$mib{'label'}</FONT></A>($$mib{'subID'})\n";
d887 22
a908 20
    }
    else {
        my ( $acc, $typ );
        if ( $$mib{'access'} eq "NoAccess" ) {
            $acc = "----";
        }
        elsif ( $$mib{'access'} eq "ReadOnly" ) {
            $acc = "-R--";
        }
        elsif ( $$mib{'access'} eq "ReadWrite" ) {
            $acc = "-RW-";
        }
        elsif ( $$mib{'access'} eq "Notify" ) {
            $acc = "---N";
        }
        elsif ( $$mib{'access'} eq "Create" ) {
            $acc = "CR--";
        }
        else {
            $acc = "    ";
d910 5
d916 2
a917 8
        if ( $$mib{'type'} eq "OBJECTID" ) {
            $typ = "ObjID    ";
        }
        elsif ( $$mib{'type'} eq "OCTETSTR" ) {
            $size = 1;
            $typ  = "String   ";
        }
        elsif ( $$mib{'type'} eq "INTEGER" || $$mib{'type'} eq "INTEGER32" ) {
d919 3
a921 48
            if ( scalar( keys %{ $mib->{'enums'} } ) > 0 ) {
                $typ = "EnumVal  ";
            }
            else {
                $typ = "Integer  ";
            }
        }
        elsif ( $$mib{'type'} eq "NETADDR" ) {
            $typ = "NetAddr  ";
        }
        elsif ( $$mib{'type'} eq "IPADDR" ) {
            $typ = "IpAddr   ";
        }
        elsif ( $$mib{'type'} eq "COUNTER" ) {
            $typ = "Counter  ";
        }
        elsif ( $$mib{'type'} eq "GAUGE" ) {
            $typ = "Gauge    ";
        }
        elsif ( $$mib{'type'} eq "TICKS" ) {
            $typ = "Timeticks";
        }
        elsif ( $$mib{'type'} eq "OPAQUE" ) {
            $size = 1;
            $typ  = "Opaque   ";
        }
        elsif ( $$mib{'type'} eq "NULL" ) {
            $typ = "Null     ";
        }
        elsif ( $$mib{'type'} eq "COUNTER64" ) {
            $typ = "Counter64";
        }
        elsif ( $$mib{'type'} eq "BITSTRING" ) {
            $typ = "BitString";
        }
        elsif ( $$mib{'type'} eq "NSAPADDRESS" ) {
            $typ = "NsapAddr ";
        }
        elsif ( $$mib{'type'} eq "UINTEGER" || $$mib{'type'} eq "UINTEGER32"
          || $$mib{'type'} eq "UNSIGNED32" )
        {
            $typ = "UInteger ";
        }
        elsif ( $$mib{'type'} eq "NOTIF" || $$mib{'type'} eq "TRAP" ) {
            $typ = "<B>Trap</B>";
        }
        else {
            $typ = "         ";
d923 3
d927 13
a939 10
        if ($test_count) {
            $tree_buffer .=
              join ( "", @@leave_indent )
              . "-- $acc $typ <A HREF=\"$ME?oid=$$mib{'label'}&xOps=tree\"><FONT COLOR=\"green\">$$mib{'label'}</FONT></A>($$mib{'subID'}) <SMALL><A HREF=\"$ME?oid=$$mib{'label'}&xOps=detail\"><FONT COLOR=\"#DC00DC\">detail</FONT></A></SMALL>\n";
        }
        else {
            $tree_buffer .=
              join ( "", @@leave_indent )
              . "-- $acc $typ <A HREF=\"$ME?oid=$$mib{'label'}&xOps=detail\"><FONT COLOR=\"#DC00DC\">$$mib{'label'}</FONT></A>($$mib{'subID'})\n";
        }
d941 6
a946 88
        $leave_indent[$ip] = $last_ipch;
        if ( $$mib{'textualConvention'} ne "" ) {
            $tree_buffer .=
              join ( "", @@leave_indent )
              . "        Textual Convention: $$mib{'textualConvention'}\n";
        }

        if ( scalar( keys %{ $mib->{'enums'} } ) > 0 ) {
            my $ep   = $$mib{'enums'};
            my $cpos = 0;
            my $cmax = $level - scalar(@@leave_indent) - 16;
            $tree_buffer .= join ( "", @@leave_indent ) . "        Values: ";
            my $key;

            foreach $key ( sort { $ep->{$a} <=> $ep->{$b} } keys %{$ep} ) {
                my $buf;
                my $bufw;
                $buf = sprintf "%s(%d)", $key, $ep->{$key};
                $cpos += ( $bufw = length($buf) + 2 );
                if ( $cpos >= $cmax ) {
                    $tree_buffer .=
                      "\n" . join ( "", @@leave_indent ) . "                ";
                    $cpos = $bufw;
                }
                $tree_buffer .= $buf;

                if ( $ep != $$mib{'enums'} ) {
                    $tree_buffer .= ", ";
                }

            }
            $tree_buffer =~ s/, $//;
            $tree_buffer .= "\n";
        }
    }

    if ( $mib->{'ranges'} && scalar( @@{ $mib->{'ranges'} } ) > 0 ) {
        my $range;
        if ( $size == 1 ) {
            $tree_buffer .= join ( "", @@leave_indent ) . "        Size: ";
        }
        else {
            $tree_buffer .= join ( "", @@leave_indent ) . "        Range: ";
        }

        foreach $range ( @@{ $mib->{'ranges'} } ) {
            my $key;
            if ( $range->{'low'} == $range->{'high'} ) {
                $tree_buffer .= $range->{'low'};
            }
            else {
                $tree_buffer .= "$range->{'low'}..$range->{'high'}";
            }
            $tree_buffer .= "|";
        }
        $tree_buffer =~ s/\|$//;
        $tree_buffer .= "\n";
    }
    $leave_indent[$ip] = $last_ipch;
    push @@leave_indent, ' ';
    push @@leave_indent, ' ';
    push @@leave_indent, '|';
    $leave_was_simple = ( $$mib{'type'} ne "" );

    my ( $count, $i );
    $count = 0;

    my $children = $$mib{'children'};
    foreach $nextOid ( @@{$children} ) {
        $count++;
    }
    if ($count) {
        $i = 0;
        my $np;

        foreach $np ( sort { $a->{'subID'} <=> $b->{'subID'} } @@{$children} ) {
            if ( ( $leave_was_simple == 0 || $leave_was_simple eq "" )
              || ( $np->{'type'} eq "" ) )
            {
                $tree_buffer .= join ( "", @@leave_indent ) . "\n";
            }

            if ( $i == $count ) {
                my $j;
                for ( $j = 0 ; $j < 3 ; $j++ ) {
                    push @@leave_indent, " ";
                }
            }
d948 2
a949 2
            print_mib_leaves( $np->{'objectID'}, $level );
            $i++;
d951 2
d954 5
a958 7
        $leave_was_simple = 0;
    }
    my $k;
    for ( $k = 0 ; $k < 3 ; $k++ ) {
        pop @@leave_indent;
    }
    return $tree_buffer;
d962 2
a963 2
    my ( $client, $data ) = @@_;
    my ($old_fh);
d965 6
a970 6
    $old_fh = select $client;
    $|      = 1;
    $data =~ s/\n/<br>/g;
    print $client $data . "\n";
    select $old_fh;
    $| = 1;
d974 2
a975 2
    my ($client) = $_[0];
    my ($data);
d977 4
a980 4
    $data = <$client>;
    $data =~ s/\W+$//g;
    $data =~ s/<br>/\n/g;
    return $data;
@


1.8
log
@When running a simple translation, the type of the object is also output.
This feature request came from CLapiana@@quallaby.com.
@
text
@d27 1
a27 1
# $Id: snmptransd.pl,v 1.7 2001/07/08 21:42:31 jmarcus Exp $
d97 1
a97 1
$rcsid = '$Id: snmptransd.pl,v 1.7 2001/07/08 21:42:31 jmarcus Exp $';
a710 2
            $data .= "</pre>\n";
            send_data( $client, $data );
d712 2
@


1.7
log
@Fixed up the new alarm clock code.  It actually returns the correct
error now.  Also, lowered the timer from 10 minutes to 5 minutes.  Most
browsers will give up by 10 minutes anyway.
@
text
@d27 1
a27 1
# $Id: snmptransd.pl,v 1.6 2001/07/08 19:15:13 jmarcus Exp $
d97 1
a97 1
$rcsid = '$Id: snmptransd.pl,v 1.6 2001/07/08 19:15:13 jmarcus Exp $';
d210 1
a210 1
    my ( $bg, $replace, $type, $size, $request );
d263 8
d334 1
a334 1
        my ($oid);
d341 6
a346 5
        $data = "<PRE>" . $oid . " = " . $trans . "</pre>\n";
        send_data( $client, $data );
    }
    elsif ( $type eq "detail" ) {
        my $numeric = 0;
d348 18
a365 3
        if ( $request =~ /^(\d+\.)+\d+$/ ) {
            $request = "." . $request;
            $numeric = 1;
d367 28
a394 2
        elsif ( $request =~ /^\.(\d+\.)+\d+$/ ) {
            $numeric = 1;
d397 4
a665 9
        my $numeric = 0;

        if ( $request =~ /^(\d+\.)+\d+$/ ) {
            $request = "." . $request;
            $numeric = 1;
        }
        elsif ( $request =~ /^\.(\d+\.)+\d+$/ ) {
            $numeric = 1;
        }
@


1.6
log
@Added support for an alarm timer.  This way, if the translate/search operation
is taking too long, the timer will abort it.  This avoids denial of service
attacks if the MIB tree is very large.
@
text
@d27 1
a27 1
# $Id: snmptransd.pl,v 1.5 2001/05/31 15:32:28 jmarcus Exp $
d53 2
a54 1
# Specify the local port for the server to bind to.  This is 3333 by default.
d59 2
a60 2
    # default is 10 minutes.
    $TIMEOUT_SECS = 600;
d97 1
a97 1
$rcsid = '$Id: snmptransd.pl,v 1.5 2001/05/31 15:32:28 jmarcus Exp $';
a162 4
# This signal handler controls what to do if the snmptrans operation runs
# for too long.  We will catch this timeout, and return an error.
$SIG{ALRM} = sub { die "timeout" };

d191 4
d292 2
d627 17
a643 1
            $data .= walkMIB( $client, $request, $request );
d662 2
@


1.5
log
@Fixed bugs in previous commit.  I _really_ need to clean up the cient/server
code.  I just don't have the time now.
@
text
@d27 1
a27 1
# $Id: snmptransd.pl,v 1.4 2001/05/31 15:16:36 jmarcus Exp $
d56 5
d77 1
a77 1
qw($rcsid $SECURITY $PIDFILE $LOCAL_PORT $REPLACE $server $MAXLEN $PREFORK $MAX_CLIENTS_PER_CHILD %children $children $ME $MIBS $MIBDIRS $HTTPMIBS %contents @@leave_indent $leave_was_simple $tree_buffer $last_ip);
d80 1
d96 1
a96 1
$rcsid = '$Id: snmptransd.pl,v 1.4 2001/05/31 15:16:36 jmarcus Exp $';
d99 6
a104 5
  LocalPort => $LOCAL_PORT,
  Type      => SOCK_STREAM,
  Proto     => 'tcp',
  Reuse     => 1,
  Listen    => 10 ) or die "Error creating socket: $@@\n";
d162 4
d276 1
a276 1
        my $mib = $SNMP::MIB{'.1'};    # Start from the root.
d278 15
a292 1
        find_occurances( $request, $search_descr, $mib, \@@occurances );
d481 1
a481 1
                  keys %{$enums} )
d630 17
a646 1
            $data .= walkMIB( $client, $request, $trans );
a647 2
        $data .= "</pre>\n";
        send_data( $client, $data );
d727 1
a727 1
. "--<A HREF=\"$ME?oid=$$mib{'label'}&xOps=tree\"><FONT COLOR=\"green\">$$mib{'label'}</FONT></A>($$mib{'subID'}) <SMALL><A HREF=\"$ME?oid=$$mib{'label'}&xOps=detail\"><FONT COLOR=\"#DC00DC\">detail</FONT></A></SMALL>\n";
d732 1
a732 1
. "--<A HREF=\"$ME?oid=$$mib{'label'}&xOps=detail\"><FONT COLOR=\"#DC00DC\">$$mib{'label'}</FONT></A>($$mib{'subID'})\n";
d819 1
a819 1
. "-- $acc $typ <A HREF=\"$ME?oid=$$mib{'label'}&xOps=tree\"><FONT COLOR=\"green\">$$mib{'label'}</FONT></A>($$mib{'subID'}) <SMALL><A HREF=\"$ME?oid=$$mib{'label'}&xOps=detail\"><FONT COLOR=\"#DC00DC\">detail</FONT></A></SMALL>\n";
d824 1
a824 1
. "-- $acc $typ <A HREF=\"$ME?oid=$$mib{'label'}&xOps=detail\"><FONT COLOR=\"#DC00DC\">$$mib{'label'}</FONT></A>($$mib{'subID'})\n";
@


1.4
log
@Added support for telling the MIB parser to replace older loaded MIB objects
with newer ones.  Note: this requires my patches to SNMP.pm which have
not yet been introduced in the official net-snmp CVS repository.

This feature will not be rolled into a release until the patch becomes
official.
@
text
@d27 1
a27 1
# $Id: snmptransd.pl,v 1.3 2001/05/24 04:32:36 jmarcus Exp $
d90 1
a90 1
$rcsid = '$Id: snmptransd.pl,v 1.3 2001/05/24 04:32:36 jmarcus Exp $';
a242 1
    send_data( $client, "200" );
@


1.3
log
@Chase down bugs in my previous commit.

This revision actually has the security working.  Again, there should be
more sanity checking in the client/server conversation.  I will get to
that if someone doesn't beat me to it.
@
text
@d27 1
a27 1
# $Id: snmptransd.pl,v 1.2 2001/05/24 04:19:05 jmarcus Exp $
d60 8
d72 1
a72 1
qw($rcsid $SECURITY $PIDFILE $LOCAL_PORT $server $MAXLEN $PREFORK $MAX_CLIENTS_PER_CHILD %children $children $ME $MIBS $MIBDIRS $HTTPMIBS %contents @@leave_indent $leave_was_simple $tree_buffer $last_ip);
d77 1
d90 1
a90 1
$rcsid = '$Id: snmptransd.pl,v 1.2 2001/05/24 04:19:05 jmarcus Exp $';
d198 1
a198 1
    my ( $bg, $type, $size, $request );
d201 4
a239 1
    $request = get_data($client);
d242 8
@


1.2
log
@Added some initial security code.

This code sort of works like CHAP, and requires the Digest::MD5 Perl module.
It's not perfect yet, but this is a start.
@
text
@d27 1
a27 1
# $Id: snmptransd.pl,v 1.1 2001/05/22 18:59:15 jmarcus Exp $
d64 1
a64 1
qw($rcsid $PIDFILE $LOCAL_PORT $server $MAXLEN $PREFORK $MAX_CLIENTS_PER_CHILD %children $children $ME $MIBS $MIBDIRS $HTTPMIBS %contents @@leave_indent $leave_was_simple $tree_buffer $last_ip);
d81 1
a81 1
$rcsid = '$Id: snmptransd.pl,v 1.1 2001/05/22 18:59:15 jmarcus Exp $';
d193 1
a193 1
        use Digest::MD5 qw(md5);
d212 1
a212 1
        $digest = get_data($client);
d214 1
a214 1
        if ( $digest eq md5($pw) ) {
@


1.1
log
@These files make up the contents of the previously committed tar.gz file.
This is a CGI frontend to net-snmp's snmptranslate command.
@
text
@d27 1
a27 1
# $Id: snmptransd.pl,v 1.2 2001/05/21 20:18:14 marcus Exp $
d55 5
d81 1
a81 1
$rcsid = '$Id: snmptransd.pl,v 1.2 2001/05/21 20:18:14 marcus Exp $';
d191 31
@

